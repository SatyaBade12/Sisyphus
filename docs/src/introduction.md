# Introduction

Optimal control strategies pervade a wide range of fields in science and engineering. In particular, quantum optimal control (QOC) has the potential to extract the best of the quantum technologies. QOC techniques are routinely employed to coherently manipulate and drive the quantum system to a given state or to perform a given quantum operation (or gate). In practice, the system dynamics and/or objective function to be minimized in QOC problems can be quite involved and often they do not yield to a simple analytical treatment (except in a few cases such as DRAG, STIRAP etc.). Therefore, one must often resort to computational methods.

Numerical techniques to solve QOC problems fall into two categories: gradient based and gradient free methods. As a general rule of thumb, gradient free methods such as [CRAB](https://arxiv.org/abs/1103.0855) and [dCRAB](https://arxiv.org/abs/1506.04601) are suitable for problems involving few tens of parameters. However, they require large number of iterations to converge as the parameter size increases and gradient based techniques should be preferred, whenever it is possible to evaluate the gradients efficiently. Among the gradient based methods, [GRAPE](https://qutip.org/docs/4.0.2/guide/guide-control.html) and [Krotov](https://qucontrol.github.io/krotov/v1.0.0/01_overview.html) solve QOC problems by representing the drive signals as piece-wise constant functions and iteratively optimize these discrete values based on the gradient of the cost function with respect to the control parameters. In these approaches, for a given set of control signals, the resulting unitary transformation is computed by first-order Trotterization of each time slice. These methods are inherently prone to discretization errors and one must sample the control signals sufficiently to obtain high fidelity protocols. A continuous parametrization of drive signals, combined with higher-order ordinary differential equation solvers are indispensible for solving optimal control problems when accuracy can not be traded with computational effort (see Gradient Optimization of Analytical conTrols [(GOAT)](https://doi.org/10.1103/physrevlett.120.150401) for a thorough discussion).

In this library, we implement a gradient based approach to solve a generic QOC problem. We rely on automatic differentiation (AD) to automatically write the [adjoint equations](https://arxiv.org/abs/1806.07366), necessary to calculate the gradients for any user defined parametrized control knobs and objective function. These equations coupled with the dynamical equations of the system are then efficiently solved to evaluate gradients. The control parameters can then be updated iteratively using any gradient based method to optimize the objective function.

## Why do we need a dedicated library for quantum optimal control?

SciML ecosystem already supports solving [optimal control problems](https://diffeqflux.sciml.ai/dev/examples/optimal_control/) via sensitivity analysis. In principle, quantum optimal control problems can be solved with this approach, however, it has two shortcomings:

a) Time evolution of Schrodinger or Master equation must be expressed only in terms of real numbers i.e. by separating the real and imaginary parts of operators and kets (it also means that we can not easily interface with `QuantumOptics.jl`). Otherwise, we'll run into errors while calculating gradients of cost function (loss) using AD.

b) The size of Hilbert space and/or the number of parameters in QOC problems can be large. In such cases, it is beneficial to implement the RHS of time evolution equations with Intel MKL or CUBLAS libraries. However, AD once again fails if the equations contain calls to functions not written in pure Julia (for e.g. when `mul!` points to Intel MKL library).

In `Sisyphus.jl` package we solve these problems by separating the AD part from the time evolution. The result is a high-performance library for quantum optimal control that enables users to: describe a general quantum optimal control problem in the familiar language of [QuantumOptics.jl](https://docs.qojulia.org/) with almost any objective for optimization, select any [ODE solver](https://diffeq.sciml.ai/dev/solvers/ode_solve/), optimizer (in [Flux.jl](https://fluxml.ai/Flux.jl/stable/training/optimisers/#Optimiser-Reference) and [NLopt.jl](https://github.com/JuliaOpt/NLopt.jl)) and solve it fast!