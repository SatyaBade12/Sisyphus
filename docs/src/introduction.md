# Introduction

Optimal control strategies pervade a wide range of fields in science and engineering. In particular, quantum optimal control (QOC) has the potential to extract the best of the quantum technologies. QOC techniques are routinely employed to coherently manipulate and drive the quantum system to a given state or to perform a given quantum operation (or gate). In practice, the system dynamics and/or objective function to be minimized in QOC problems can be quite involved and often they do not yield to a simple analytical treatment (except a few cases such as DRAG, STIRAP etc.). Therefore, one must resort to computational methods.

Numerical techniques to solve QOC problems fall into two categories: gradient based and gradient free methods. As a general rule of thumb, gradient free methods such as [CRAB](https://arxiv.org/abs/1103.0855) and [dCRAB](https://arxiv.org/abs/1506.04601) are suitable for problems with few tens of parameters. However, these methods may require large number of iterations to converge as the parameter size increases and we should switch to gradient (if it is possible to evaluate) based techniques. Methods such as [GRAPE](https://qutip.org/docs/4.0.2/guide/guide-control.html) and [Krotov](https://qucontrol.github.io/krotov/v1.0.0/01_overview.html) solve QOC problems by representing the drive signals as piece-wise constant functions and iteratively optimize these discrete values based on the gradient of the cost function with respect to the control parameters. In these approaches, for a given set of control signals, the resulting unitary transformation is computed by first-order Trotterization of each time slice. These methods are inherently prone to discretization errors and one must sample the control signals sufficiently to obtain high fidelity protocols. A continuous parametrization of drive signals, combined with higher-order ordinary differential equation solvers are indispensible for solving optimal control problems when accuracy can not be traded with computational effort (see for e.g. [GOAT](https://doi.org/10.1103/physrevlett.120.150401)).

In this library, we provide a flexible framework to express QOC problems in most quantum technologies with almost any objective function (automatic differentiation (AD) calculates the necessary gradients) and solve it with a high performance gradient based solver!

## Why do we need a dedicated library for quantum optimal control?

SciML ecosystem already supports solving [optimal control problems](https://diffeqflux.sciml.ai/dev/examples/optimal_control/) via sensitivity analysis. In principle, quantum optimal control problems can be solved with this approach, however, it has two shortcomings:

a) One should express the time evolution of Schrodinger or Master equation only in real numbers i.e. by separating the real and imaginary parts of operators and kets (it also means that we can not easily interface it with `QuantumOptics.jl`). Otherwise, we'll run into errors while calculating gradients of cost function (loss) using automatic differentiation (AD).

b) The size of Hilbert space and/or the number of parameters in quantum optimal control problems can be large. In such cases, it is beneficial to implement the RHS of time evolution equations with Intel MKL or CUBLAS libraries. However, AD once again fails if the equations contain calls to functions not written in pure Julia (for e.g. when `mul!` points to Intel MKL library).

In `Sisyphus.jl` package we solve these problems by separating the AD part from the time evolution. The result is a high-performance library for quantum optimal control that enables users to: describe a general quantum optimal control problem in the familiar language of [QuantumOptics.jl](https://docs.qojulia.org/) with almost any objective for optimization, select any [ODE solver](https://diffeq.sciml.ai/dev/solvers/ode_solve/), optimizer (in [Flux.jl](https://fluxml.ai/Flux.jl/stable/training/optimisers/#Optimiser-Reference) and [NLopt.jl](https://github.com/JuliaOpt/NLopt.jl)) and solve it fast!