<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · Sisyphus.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Sisyphus.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><a class="tocitem" href="installation.html">Installation</a></li><li><a class="tocitem" href="introduction.html">Introduction</a></li><li><a class="tocitem" href="gbqoc.html">Gradient-based QOC</a></li><li><a class="tocitem" href="noisy.html">Open quantum systems</a></li><li class="is-active"><a class="tocitem" href="tutorial.html">Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Constructing-a-[Hamiltonian](@ref)"><span>Constructing a <code>Hamiltonian</code></span></a></li><li><a class="tocitem" href="#Defining-a-[Transform](@ref)"><span>Defining a <code>Transform</code></span></a></li><li><a class="tocitem" href="#Constructing-a-[CostFunction](@ref)"><span>Constructing a <code>CostFunction</code></span></a></li><li><a class="tocitem" href="#Creating-and-solving-a-[QOCProblem](@ref)"><span>Creating and solving a <code>QOCProblem</code></span></a></li><li><a class="tocitem" href="#Selecting-an-optimizer"><span>Selecting an optimizer</span></a></li><li><a class="tocitem" href="#Selecting-a-differential-equation-solver"><span>Selecting a differential equation solver</span></a></li><li><a class="tocitem" href="#Optimization-in-the-presence-of-noise"><span>Optimization in the presence of noise</span></a></li><li><a class="tocitem" href="#Solving-problems-on-GPU"><span>Solving problems on GPU</span></a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="examples/DRAG.html">DRAG</a></li><li><a class="tocitem" href="examples/TwoLevelSystem.html">Two-level system</a></li><li><a class="tocitem" href="examples/TwoLevelSystemNoisy.html">Noisy two-level system</a></li><li><a class="tocitem" href="examples/RXpi2.html">Rₓ(π/2)</a></li><li><a class="tocitem" href="examples/SQRTiSWAP.html">√iSWAP</a></li><li><a class="tocitem" href="examples/CZ2.html">CZ</a></li><li><a class="tocitem" href="examples/GHZState.html">GHZ state</a></li><li><a class="tocitem" href="examples/GHZStateCUDANeuralNetwork.html">GHZ state 12 atoms (CUDA)</a></li><li><a class="tocitem" href="examples/GHZStateCUDALinearInterp.html">GHZ state 16 atoms (CUDA)</a></li></ul></li><li><a class="tocitem" href="api.html">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="tutorial.html">Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="tutorial.html">Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SatyaBade12/Sisyphus.jl/blob/main/docs/src/tutorial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h1><p>The main goal of this tutorial is to introduce the terminology and workflow of the package.</p><h2 id="Constructing-a-[Hamiltonian](@ref)"><a class="docs-heading-anchor" href="#Constructing-a-[Hamiltonian](@ref)">Constructing a <a href="api.html#Sisyphus.Hamiltonian"><code>Hamiltonian</code></a></a><a id="Constructing-a-[Hamiltonian](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-a-[Hamiltonian](@ref)" title="Permalink"></a></h2><p>We split the Hamiltonian into time-independent and time-dependent parts. Operators constituting the Hamiltonian are represented by QuantumOptics operators. For a list of operators we submit a drives function that returns the corresponding list of real-valued drives that multiplies the operators respectively. Below is a construction of a simple two-level Hamiltonian with a parameterized Gaussian shaped drive</p><p class="math-container">\[H(t)/\hbar\omega_0 = -\frac{1}{2}\sigma_z + \Omega(p, t)\sigma_x\]</p><pre><code class="language-julia hljs">bs = SpinBasis(1//2)
Ω(p, t) = [p[1] * exp(-p[2] * t^2) + p[3]]
H = Hamiltonian(-0.5*sigmaz(bs), [sigmax(bs)], Ω)</code></pre><p>The real valued drives can be any function in Julia, as long as it is differentiable. You can find some examples showcasing the use of neural networks, piecewise constant and linear functions in the notebooks.</p><h2 id="Defining-a-[Transform](@ref)"><a class="docs-heading-anchor" href="#Defining-a-[Transform](@ref)">Defining a <a href="api.html#Sisyphus.Transform"><code>Transform</code></a></a><a id="Defining-a-[Transform](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-a-[Transform](@ref)" title="Permalink"></a></h2><h3 id="a)-[StateTransform](@ref)"><a class="docs-heading-anchor" href="#a)-[StateTransform](@ref)">a) <a href="api.html#Sisyphus.StateTransform"><code>StateTransform</code></a></a><a id="a)-[StateTransform](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#a)-[StateTransform](@ref)" title="Permalink"></a></h3><p>Transformation can be defined between two Kets as in the following code.</p><pre><code class="language-julia hljs">bs = SpinBasis(1//2)
trans = StateTransform(spindown(bs) =&gt; spinup(bs))</code></pre><h3 id="b)-[UnitaryTransform](@ref)"><a class="docs-heading-anchor" href="#b)-[UnitaryTransform](@ref)">b) <a href="api.html#Sisyphus.UnitaryTransform"><code>UnitaryTransform</code></a></a><a id="b)-[UnitaryTransform](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#b)-[UnitaryTransform](@ref)" title="Permalink"></a></h3><p>It can alternatively be defined on a vector of Kets by providing unitary matrix that acts on the subspace spanned by them and represents the desired unitary evolution.</p><pre><code class="language-julia hljs">bs = FockBasis(5)

states = [fockstate(bs, 0)⊗fockstate(bs, 0),
          fockstate(bs, 0)⊗fockstate(bs, 1),
          fockstate(bs, 1)⊗fockstate(bs, 0),
          fockstate(bs, 1)⊗fockstate(bs, 1)]

trans = UnitaryTransform(states, [[1.0 0.0 0.0 0.0];
                                  [0.0 1.0 1.0im 0.0]/√2;
                                  [0.0 1.0im 1.0 0.0]/√2;
                                  [0.0 0.0 0.0 1.0]])</code></pre><h2 id="Constructing-a-[CostFunction](@ref)"><a class="docs-heading-anchor" href="#Constructing-a-[CostFunction](@ref)">Constructing a <a href="api.html#Sisyphus.CostFunction"><code>CostFunction</code></a></a><a id="Constructing-a-[CostFunction](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-a-[CostFunction](@ref)" title="Permalink"></a></h2><p>Cost function is composed of a distance function measuring the overlap of the quantum states and the optional constraints on the shape of pulses. The following code defines a cost function that measures the infidelity between quantum states and constrains the pulse to zero at initial and final times <code>t0</code> and <code>t1</code>.</p><pre><code class="language-julia hljs">(t0, t1) = (0.0, 1.0)
Ω(p, t) = [p[1] * exp(-p[2] * t^2) + p[3]]
cost = CostFunction((x, y) -&gt; 1.0 - abs2(x&#39; * y),
                     p -&gt; Ω(p, t0)[1]^2 + Ω(p, t1)[1]^2)</code></pre><p>The solver automatically calculates the gradient of the distance and constraints function wrt the parameters of the problem. Therefore, the <code>CostFunction</code> arguments have to be differentiable real valued functions (<code>Zygote</code> handles most functions, just try!).</p><h2 id="Creating-and-solving-a-[QOCProblem](@ref)"><a class="docs-heading-anchor" href="#Creating-and-solving-a-[QOCProblem](@ref)">Creating and solving a <a href="api.html#Sisyphus.QOCProblem"><code>QOCProblem</code></a></a><a id="Creating-and-solving-a-[QOCProblem](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-and-solving-a-[QOCProblem](@ref)" title="Permalink"></a></h2><p>Once we have constructed the Hamiltonian, cost function, and target unitary transformation, we can define a quantum optimal control problem by submitting a timeframe <code>(t0, t1)</code> for the evolution along the previously mentioned objects and functions. <code>QOCProblem</code> can be solved by invoking the <code>solve</code> method that can further be customized, e.g. through the selection of an optimizer or by setting optimization hyperparameters like below.</p><pre><code class="language-julia hljs">prob = QOCProblem(H, trans, (t0, t1), cost)
sol = solve(prob, initial_params, ADAM(0.01);)</code></pre><p>The <a href="api.html#Sisyphus.Solution"><code>Solution</code></a> returned by the solver contains the optimal parameters and also the values of distance metric and constraints during the optimization process.</p><p>Optionally, you can use the following keywords while invoking the <code>solve</code> method:</p><p>a) <code>maxiter</code> allows to set the maximum number of iterations, the default value is <code>100</code>.</p><p>b) <code>save_iters</code> to save the parameters tried by the optimizer at the specified iterations (useful for visualization of optimization). By default, the <a href="api.html#Sisyphus.Solution"><code>Solution</code></a> object returned by the solver does not contain intermediate results.</p><h2 id="Selecting-an-optimizer"><a class="docs-heading-anchor" href="#Selecting-an-optimizer">Selecting an optimizer</a><a id="Selecting-an-optimizer-1"></a><a class="docs-heading-anchor-permalink" href="#Selecting-an-optimizer" title="Permalink"></a></h2><p>User can pick any of the available optimizers from the Flux or NLopt packages, for example</p><pre><code class="language-julia hljs">using Flux.Optimise: RMSProp
sol = solve(prob, initial_params, RMSProp(0.01); maxiter=100)</code></pre><h2 id="Selecting-a-differential-equation-solver"><a class="docs-heading-anchor" href="#Selecting-a-differential-equation-solver">Selecting a differential equation solver</a><a id="Selecting-a-differential-equation-solver-1"></a><a class="docs-heading-anchor-permalink" href="#Selecting-a-differential-equation-solver" title="Permalink"></a></h2><p>The ODE solver used to compute the system dynamics and gradients can be chosen with the keyword <code>alg</code>.</p><pre><code class="language-julia hljs">sol = solve(prob, initial_params, ADAM(0.01); maxiter=100, alg=DP5(), abstol=1e-6, reltol=1e-6)</code></pre><p>You may select appropriate ODE solvers available in <code>OrdinaryDiffEq</code> package. By default <code>Sisyphus.jl</code> uses <code>Tsit5()</code> algorithm, we encourage you to go through the documentation of <a href="https://diffeq.sciml.ai/stable/solvers/ode_solve/#ode_solve">ODE Solvers</a> and try different algorithms to identify the algorithm best suited for your problem. In addition, you can also control the solver tolerances by setting <code>abstol</code> and <code>reltol</code>.</p><h2 id="Optimization-in-the-presence-of-noise"><a class="docs-heading-anchor" href="#Optimization-in-the-presence-of-noise">Optimization in the presence of noise</a><a id="Optimization-in-the-presence-of-noise-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization-in-the-presence-of-noise" title="Permalink"></a></h2><p>Optimal control problems in the presence of Lindbladian noise can be solved by converting them into an equivalent <a href="noisy.html">closed system problem</a> by vectorizing the master equation. Here, we only provide tools to convert <a href="api.html#Sisyphus.Hamiltonian"><code>Hamiltonian</code></a> and <a href="api.html#Sisyphus.Transform"><code>Transform</code></a>s into their vectorized forms. However, it is the responsibility of the users to provide an appropriate distance measure between the two density matrices in the <a href="api.html#Sisyphus.CostFunction"><code>CostFunction</code></a> (check examples) while working with the vectorized forms. For example, one can write Frobenius norm in its vectorized form as</p><p class="math-container">\[\|\rho - \sigma\|_F = \sqrt{\text{Tr}(\rho - \sigma)^\dagger(\rho - \sigma)} = \sqrt{\text{vec}(\rho - \sigma)^\dagger\text{vec}(\rho - \sigma)},\]</p><p>and define a correspoding distance function as <code>(x, y) -&gt; 1.0 - sqrt((x - y)&#39; * (x - y))</code>.</p><h2 id="Solving-problems-on-GPU"><a class="docs-heading-anchor" href="#Solving-problems-on-GPU">Solving problems on GPU</a><a id="Solving-problems-on-GPU-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-problems-on-GPU" title="Permalink"></a></h2><p>Usually, all the kets and operators in <code>QOCProblem</code> are allocated on the CPU. In order to solve the problem on a GPU, we need to move the data to GPU memory, this can be done simply with the <a href="api.html#CUDA.cu"><code>cu</code></a> function as shown below. Once the data is moved to the GPU, the problem can be solved with the <code>solve</code> method as usual</p><pre><code class="language-julia hljs">cu_prob = cu(QOCProblem(H, trans, (t0, t1), cost))
solve(cu_prob, init_params, ADAM(0.1); maxiter=100)</code></pre><p>GPUs have better single precision performance, if your problem does not require double precision, it is better to use single precision to obtain results quicker (it also reduces the memory footprint). We provide <a href="api.html#Base.convert-Tuple{Type{Float32}, QOCProblem}"><code>convert</code></a> method to automatically convert all data types to single precision,</p><pre><code class="language-julia hljs">prob = cu(convert(Float32, QOCProblem(H, trans, (t0, t1), cost)))</code></pre><p>notebooks demonstrating these features can be found in the examples.</p><h3 id="How-to-choose-a-CostFunction?"><a class="docs-heading-anchor" href="#How-to-choose-a-CostFunction?">How to choose a <code>CostFunction</code>?</a><a id="How-to-choose-a-CostFunction?-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-choose-a-CostFunction?" title="Permalink"></a></h3><p>We have to bear in mind that the distance function (specified in <code>CostFunction</code>) must operate on arrays allocated on GPU. Most of the time, Julia&#39;s GPU compiler automatically generates CUDA kernels behind the scenes, both for distance and it&#39;s gradient! However it fails sometimes, for example, you should use,</p><pre><code class="language-julia hljs">cost = CostFunction((x, y) -&gt; 1.0 - real(sum(conj(x) .* y))</code></pre><p>instead of,</p><pre><code class="language-julia hljs">cost = CostFunction((x, y) -&gt; 1.0 - real(x&#39; * y)</code></pre><p>eventhough they are equivalent. Solving this in general is beyond the scope of <code>Sisyphus.jl</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="noisy.html">« Open quantum systems</a><a class="docs-footer-nextpage" href="examples/DRAG.html">DRAG »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 23 June 2023 06:29">Friday 23 June 2023</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
