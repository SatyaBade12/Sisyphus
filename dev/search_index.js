var documenterSearchIndex = {"docs":
[{"location":"examples/GHZStateCUDANeuralNetwork.html#GHZ-state-in-Rydberg-atoms-(CUDA)","page":"GHZ state 12 atoms (CUDA)","title":"GHZ state in Rydberg atoms (CUDA)","text":"","category":"section"},{"location":"examples/GHZStateCUDANeuralNetwork.html","page":"GHZ state 12 atoms (CUDA)","title":"GHZ state 12 atoms (CUDA)","text":"using Sisyphus\nusing QuantumOptics\nusing LinearAlgebra\nusing Flux, DiffEqFlux\nusing Plots\nusing ProgressMeter\nusing Random\nProgressMeter.ijulia_behavior(:clear)","category":"page"},{"location":"examples/GHZStateCUDANeuralNetwork.html","page":"GHZ state 12 atoms (CUDA)","title":"GHZ state 12 atoms (CUDA)","text":"false","category":"page"},{"location":"examples/GHZStateCUDANeuralNetwork.html","page":"GHZ state 12 atoms (CUDA)","title":"GHZ state 12 atoms (CUDA)","text":"bs = SpinBasis(1//2)\nsx = sigmax(bs)\nni = 0.5*(identityoperator(bs) + sigmaz(bs))","category":"page"},{"location":"examples/GHZStateCUDANeuralNetwork.html","page":"GHZ state 12 atoms (CUDA)","title":"GHZ state 12 atoms (CUDA)","text":"V = 2π*24.0\nδe = -2π*4.5","category":"page"},{"location":"examples/GHZStateCUDANeuralNetwork.html","page":"GHZ state 12 atoms (CUDA)","title":"GHZ state 12 atoms (CUDA)","text":"-28.274333882308138","category":"page"},{"location":"examples/GHZStateCUDANeuralNetwork.html","page":"GHZ state 12 atoms (CUDA)","title":"GHZ state 12 atoms (CUDA)","text":"n_atoms = 12\nbsys = tensor([bs for i in 1:n_atoms]...)\n\nH0 = V*sum([embed(bsys, [i, j], [ni, ni])/abs(i-j)^6  for i in 1:n_atoms for j in i+1:n_atoms])\nH0 -= δe*sum([embed(bsys, [i], [ni]) for i in [1, n_atoms]])\nif n_atoms>8\n    H0 -= -2π*1.5*sum([embed(bsys, [i], [ni]) for i in [1, n_atoms]])\n    H0 -= -2π*1.5*sum([embed(bsys, [i], [ni]) for i in [4, n_atoms-3]])\nend;\n\nH1 = 0.5*sum([embed(bsys, [i], [sx]) for i in 1:n_atoms])\nH2 = -sum([embed(bsys, [i], [ni]) for i in 1:n_atoms])","category":"page"},{"location":"examples/GHZStateCUDANeuralNetwork.html","page":"GHZ state 12 atoms (CUDA)","title":"GHZ state 12 atoms (CUDA)","text":"function GHZ_state(n_atoms)\n    state = tensor([spindown(bs)⊗spinup(bs) for i in 1:Int(n_atoms/2)]...) +\n            tensor([spinup(bs)⊗spindown(bs) for i in 1:Int(n_atoms/2)]...)\n    state/sqrt(2.0)\nend \n\nground_state(n_atoms) = tensor([spindown(bs) for i in 1:n_atoms]...)\ntrans = StateTransform(ground_state(n_atoms)=>GHZ_state(n_atoms))","category":"page"},{"location":"examples/GHZStateCUDANeuralNetwork.html","page":"GHZ state 12 atoms (CUDA)","title":"GHZ state 12 atoms (CUDA)","text":"n_neurons = 8\nsigmoid(x)= @. 2π*7 / (1 + exp(-x))\nRandom.seed!(10)\nann = FastChain(FastDense(1, n_neurons, tanh), \n                FastDense(n_neurons, n_neurons, tanh), \n                FastDense(n_neurons, 2))\nθ = initial_params(ann)  \nn_params = length(θ)","category":"page"},{"location":"examples/GHZStateCUDANeuralNetwork.html","page":"GHZ state 12 atoms (CUDA)","title":"GHZ state 12 atoms (CUDA)","text":"106","category":"page"},{"location":"examples/GHZStateCUDANeuralNetwork.html","page":"GHZ state 12 atoms (CUDA)","title":"GHZ state 12 atoms (CUDA)","text":"t0, t1 = 0.0, 0.5\n\ntsf32 = Float32(t0):Float32(t1/49):Float32(t1)\nΩs = Vector{Float32}(2π*vcat(0:0.5:4, 5*ones(32), 4:-0.5:0))\nΔs = Vector{Float32}(2π*(-5:10/49:5))\nts = Vector{Float64}(tsf32)\n\nfunction loss(p)\n    c = 0.0f0\n    for (i,t) in enumerate(tsf32)\n        x = ann([t], p)\n        c += (abs(x[1]) - Ωs[i])^2\n        c += (x[2] - Δs[i])^2\n    end\n    #println(c)\n    c\nend\n\nres = DiffEqFlux.sciml_train(loss, initial_params(ann), Adam(0.1f0), maxiters = 5000)\nθ = Vector{Float64}(res.u)","category":"page"},{"location":"examples/GHZStateCUDANeuralNetwork.html","page":"GHZ state 12 atoms (CUDA)","title":"GHZ state 12 atoms (CUDA)","text":"coeffs(params, t) = let vals = ann([t], params)\n                        [abs(vals[1]), vals[2]]\n                    end    \n\ncost = CostFunction((x, y) -> 1.0 - abs(sum(conj(x).*y)),\n                     p->2e-3*(abs(ann([t0], p)[1])+ 5.0*abs(ann([t1], p)[1])))","category":"page"},{"location":"examples/GHZStateCUDANeuralNetwork.html","page":"GHZ state 12 atoms (CUDA)","title":"GHZ state 12 atoms (CUDA)","text":"CostFunction(var\"#23#25\"(), var\"#24#26\"())","category":"page"},{"location":"examples/GHZStateCUDANeuralNetwork.html","page":"GHZ state 12 atoms (CUDA)","title":"GHZ state 12 atoms (CUDA)","text":"H = Hamiltonian(H0, [H1, H2], coeffs)","category":"page"},{"location":"examples/GHZStateCUDANeuralNetwork.html","page":"GHZ state 12 atoms (CUDA)","title":"GHZ state 12 atoms (CUDA)","text":"prob = cu(convert(Float32, QOCProblem(H, trans, (t0, t1), cost)))","category":"page"},{"location":"examples/GHZStateCUDANeuralNetwork.html","page":"GHZ state 12 atoms (CUDA)","title":"GHZ state 12 atoms (CUDA)","text":"@time sol = solve(prob, res.u, Adam(0.1f0); maxiter=200, abstol=1e-5, reltol=1e-5)","category":"page"},{"location":"examples/GHZStateCUDANeuralNetwork.html","page":"GHZ state 12 atoms (CUDA)","title":"GHZ state 12 atoms (CUDA)","text":"\u001b[32mProgress: 100%|█████████████████████████████████████████| Time: 0:24:04\u001b[39m\r\n\u001b[34m  distance:     0.015626370906829834\u001b[39m\r\n\u001b[34m  constraints:  0.00787696664318554\u001b[39m\n\n\n1477.884612 seconds (5.61 G allocations: 139.938 GiB, 9.92% gc time, 4.95% compilation time)\n\n\n\n\n\nSolution{Float32}(Float32[-4.9095097, -3.258889, 3.6414409, -4.336866, -9.806632, -8.169109, 8.890097, -3.5882354, 0.9342948, 1.4838762  …  3.554006, -6.394788, 7.13117, -7.1935782, 1.7162676, 17.924551, 19.362608, 3.5637567, 1.9719929, 6.20059], Float32[0.89177257, 0.81607366, 0.8562323, 0.7666775, 0.8015005, 0.81758726, 0.7245367, 0.69440055, 0.69403017, 0.64353585  …  0.017134845, 0.019722283, 0.019384205, 0.017207801, 0.015501082, 0.017275393, 0.018748641, 0.0206362, 0.016470194, 0.01562637], Float32[0.010842906, 0.04914394, 0.05029069, 0.039492287, 0.018102482, 0.026509503, 0.016885282, 0.032451477, 0.035936307, 0.028652746  …  0.0072718617, 0.0016285173, 0.00038689838, 0.008437778, 0.011504921, 0.0068363417, 0.0026388576, 0.0023839504, 0.0051434184, 0.007876967], Vector{Float32}[])","category":"page"},{"location":"examples/GHZStateCUDANeuralNetwork.html","page":"GHZ state 12 atoms (CUDA)","title":"GHZ state 12 atoms (CUDA)","text":"plot(sol.distance_trace)\nplot!(sol.constraints_trace)","category":"page"},{"location":"examples/GHZStateCUDANeuralNetwork.html","page":"GHZ state 12 atoms (CUDA)","title":"GHZ state 12 atoms (CUDA)","text":"(Image: svg)","category":"page"},{"location":"examples/GHZStateCUDANeuralNetwork.html","page":"GHZ state 12 atoms (CUDA)","title":"GHZ state 12 atoms (CUDA)","text":"Ω(t) = abs(ann([t], sol.params)[1])/2π\nΔ(t) = ann([t], sol.params)[2]/2π\nts = Vector{Float32}(collect(t0:0.001:t1))\n\nblue = theme_palette(:auto).colors.colors[1]\nred = theme_palette(:auto).colors.colors[2]\nplot(ts, Δ.(ts), ylabel=\"Δ/2π (MHz)\",\n     color=blue, yguidefont = font(blue), legend=false)\nplot!(Plots.twinx(), ts, Ω.(ts)/2π,\n     ylabel=\"Ω/2π (MHz)\", color=red, yguidefont = font(red), legend=false)\nplot!(xlabel=\"time (μs)\", right_margin = 15Plots.mm)","category":"page"},{"location":"examples/GHZStateCUDANeuralNetwork.html","page":"GHZ state 12 atoms (CUDA)","title":"GHZ state 12 atoms (CUDA)","text":"(Image: svg)","category":"page"},{"location":"examples/GHZStateCUDANeuralNetwork.html","page":"GHZ state 12 atoms (CUDA)","title":"GHZ state 12 atoms (CUDA)","text":"tout, psit = schroedinger_dynamic(ts, ground_state(n_atoms), H, Vector{Float64}(sol.params))","category":"page"},{"location":"examples/GHZStateCUDANeuralNetwork.html","page":"GHZ state 12 atoms (CUDA)","title":"GHZ state 12 atoms (CUDA)","text":"plot(ts, real(expect(dm(GHZ_state(n_atoms)), psit)))\nxlabel!(\"Time (µs)\")\nylabel!(\"Overlap (|⟨ψ|GHZ⟩|²)\")","category":"page"},{"location":"examples/GHZStateCUDANeuralNetwork.html","page":"GHZ state 12 atoms (CUDA)","title":"GHZ state 12 atoms (CUDA)","text":"(Image: svg)","category":"page"},{"location":"examples/TwoLevelSystemNoisy.html#Noisy-two-level-system","page":"Noisy two-level system","title":"Noisy two-level system","text":"","category":"section"},{"location":"examples/TwoLevelSystemNoisy.html","page":"Noisy two-level system","title":"Noisy two-level system","text":"The dynamics of open quantum systems can be described with a master equation","category":"page"},{"location":"examples/TwoLevelSystemNoisy.html","page":"Noisy two-level system","title":"Noisy two-level system","text":"dotrho = -iH rho  + sum_k gamma_k big( J_k rho J_k^dagger - frac12 J_k^dagger J_k rho - frac12 rho J_k^dagger J_k big)","category":"page"},{"location":"examples/TwoLevelSystemNoisy.html","page":"Noisy two-level system","title":"Noisy two-level system","text":"where J_k are jump operators and gamma_k corresponding jump rates. We again consider a simple two-level system Hamiltonian","category":"page"},{"location":"examples/TwoLevelSystemNoisy.html","page":"Noisy two-level system","title":"Noisy two-level system","text":"H(t) = -fracomega_02sigma_z + Omega(t)sigma_x","category":"page"},{"location":"examples/TwoLevelSystemNoisy.html","page":"Noisy two-level system","title":"Noisy two-level system","text":"in a noisy setting by introducing relaxation through a jump operator J_1 = sigma_- and with rate gamma_1 = 001.","category":"page"},{"location":"examples/TwoLevelSystemNoisy.html","page":"Noisy two-level system","title":"Noisy two-level system","text":"using Sisyphus\nusing QuantumOptics\nusing Flux, DiffEqFlux\nusing Plots\nusing Random\nusing ProgressMeter\n\nProgressMeter.ijulia_behavior(:clear)","category":"page"},{"location":"examples/TwoLevelSystemNoisy.html","page":"Noisy two-level system","title":"Noisy two-level system","text":"n_neurons = 4\n\nRandom.seed!(0)\nann = FastChain(FastDense(1, n_neurons, tanh), \n                FastDense(n_neurons, n_neurons, tanh),\n                FastDense(n_neurons, n_neurons, tanh),\n                FastDense(n_neurons, 1))\nθ = Vector{Float64}(initial_params(ann));\n\nprintln(\"Number of parameters: \", length(θ))\n\nΩ(params, t) = ann([t], params)[1]","category":"page"},{"location":"examples/TwoLevelSystemNoisy.html","page":"Noisy two-level system","title":"Noisy two-level system","text":"Number of parameters: 53","category":"page"},{"location":"examples/TwoLevelSystemNoisy.html","page":"Noisy two-level system","title":"Noisy two-level system","text":"Let's first consider our problem without the noise by minimizing the infidelity.","category":"page"},{"location":"examples/TwoLevelSystemNoisy.html","page":"Noisy two-level system","title":"Noisy two-level system","text":"(t0, t1) = (0.0, 1.0)\ncost = CostFunction((x, y) -> 1.0 - abs2(x'*y), p -> Ω(p, t0)^2 + Ω(p, t1)^2)\n\nbs = SpinBasis(1//2)\ntrans = StateTransform(spindown(bs)=>spinup(bs))\nH = Hamiltonian(-0.5*sigmaz(bs), [sigmax(bs)], Ω)\n\nprob = QOCProblem(H, trans, (t0, t1), cost)\n@time sol = solve(prob, θ, Adam(0.05); maxiter=1000, abstol=1e-8, reltol=1e-8)","category":"page"},{"location":"examples/TwoLevelSystemNoisy.html","page":"Noisy two-level system","title":"Noisy two-level system","text":"\u001b[32mProgress: 100%|█████████████████████████████████████████| Time: 0:06:47\u001b[39m\r\n\u001b[34m  distance:     7.051431005766773e-8\u001b[39m\r\n\u001b[34m  constraints:  1.836876500130954e-7\u001b[39m\n\n\n436.762505 seconds (367.22 M allocations: 38.639 GiB, 80.05% gc time, 13.77% compilation time)","category":"page"},{"location":"examples/TwoLevelSystemNoisy.html","page":"Noisy two-level system","title":"Noisy two-level system","text":"ts = t0:t1/100:t1\n\nplot(ts, [Ω(sol.params, t) for t in ts])\nplot!(xlabel=\"t (a.u.)\", ylabel=\"Ω / ω₀\", legend=false)","category":"page"},{"location":"examples/TwoLevelSystemNoisy.html","page":"Noisy two-level system","title":"Noisy two-level system","text":"(Image: svg)","category":"page"},{"location":"examples/TwoLevelSystemNoisy.html","page":"Noisy two-level system","title":"Noisy two-level system","text":"In order to solve the noisy problem with the existing machinery, we have to vectorize our master equation such that it takes on the form of a Schrödinger equation. We do this by applying the vectorization identity textvec(A B C) = (C^T otimes A)textvec(B) using vectorize methods.","category":"page"},{"location":"examples/TwoLevelSystemNoisy.html","page":"Noisy two-level system","title":"Noisy two-level system","text":"Since our initial state is a pure state psirangle = downarrowrangle, we can represent the overlap with the final mixed state using the formula langlepsirhopsirangle = textTr(psiranglelanglepsirho). We can use another vectorization identity, textTr(A^dagger B) = textvec(A)^daggertextvec(B), to get textTr(psiranglelanglepsirho) = textvec(psiranglelanglepsi)^daggertextvec(rho). Then the infidelity can be measured with the cost function (x, y) -> 1.0 - real(x' * y). Note that this infidelity measure matches the one used above for pure states.","category":"page"},{"location":"examples/TwoLevelSystemNoisy.html","page":"Noisy two-level system","title":"Noisy two-level system","text":"costv = CostFunction((x, y) -> 1.0 - real(x'*y), p -> Ω(p, t0)^2 + Ω(p, t1)^2)\n\ntransv = vectorize(trans)\nJ = [sigmam(bs)]\nrates = [0.01]\nHv = vectorize(H, J, rates)","category":"page"},{"location":"examples/TwoLevelSystemNoisy.html","page":"Noisy two-level system","title":"Noisy two-level system","text":"Let us evolve the noisy system using the pulse optimized for the noiseless case.","category":"page"},{"location":"examples/TwoLevelSystemNoisy.html","page":"Noisy two-level system","title":"Noisy two-level system","text":"tout, psit = master_dynamic((t0, t1), spindown(bs), H, sol.params, J, rates)\nprintln(\"Infidelity: \", costv.distance(vectorize(spinup(bs)).data, vec(psit[end].data)))","category":"page"},{"location":"examples/TwoLevelSystemNoisy.html","page":"Noisy two-level system","title":"Noisy two-level system","text":"Infidelity: 0.0028828993080145526","category":"page"},{"location":"examples/TwoLevelSystemNoisy.html","page":"Noisy two-level system","title":"Noisy two-level system","text":"probv = QOCProblem(Hv, transv, (t0, t1), costv)\n@time solv = solve(probv, sol.params, Adam(0.05); maxiter=1000, abstol=1e-8, reltol=1e-8)","category":"page"},{"location":"examples/TwoLevelSystemNoisy.html","page":"Noisy two-level system","title":"Noisy two-level system","text":"\u001b[32mProgress: 100%|█████████████████████████████████████████| Time: 0:06:06\u001b[39m\r\n\u001b[34m  distance:     0.002472913289868317\u001b[39m\r\n\u001b[34m  constraints:  2.895772702259745e-7\u001b[39m\n\n\n367.073293 seconds (331.51 M allocations: 45.108 GiB, 87.86% gc time, 0.38% compilation time)","category":"page"},{"location":"examples/TwoLevelSystemNoisy.html","page":"Noisy two-level system","title":"Noisy two-level system","text":"plot(ts, [Ω(sol.params, t) for t in ts], label=\"Noiseless\")\nplot!(ts, [Ω(solv.params, t) for t in ts], label=\"Noisy\")\nplot!(xlabel=\"t (a.u.)\", ylabel=\"Ω / ω₀\")","category":"page"},{"location":"examples/TwoLevelSystemNoisy.html","page":"Noisy two-level system","title":"Noisy two-level system","text":"(Image: svg)","category":"page"},{"location":"examples/TwoLevelSystemNoisy.html","page":"Noisy two-level system","title":"Noisy two-level system","text":"tout, psit = schroedinger_dynamic((t0, t1), spindown(bs), H, solv.params)\nprintln(\"Noiseless infidelity: \", cost.distance(spinup(bs).data, psit[end].data))\n\ntout, psit = master_dynamic((t0, t1), spindown(bs), H, solv.params, J, rates)\nprintln(\"Noisy infidelity: \", costv.distance(vectorize(spinup(bs)).data, vec(psit[end].data)))","category":"page"},{"location":"examples/TwoLevelSystemNoisy.html","page":"Noisy two-level system","title":"Noisy two-level system","text":"Noiseless infidelity: 2.021542197638837e-6\nNoisy infidelity: 0.002471508213857332","category":"page"},{"location":"examples/CZ2.html#CZ-gate-in-Rydberg-atoms","page":"CZ","title":"CZ gate in Rydberg atoms","text":"","category":"section"},{"location":"examples/CZ2.html","page":"CZ","title":"CZ","text":"In order to implement digital quantum computation in Rydberg atoms, ground state grangle and hyperfine state hrangle are used as qubit states. Transitions between these two levels grangle leftrightarrow hrangle can be induced with Raman pulses. However, in order to create entanglement between two atoms, another ancillary atomic level has to be introduced and it's called the Rydberg level rrangle (essentially a highly excited state). Transitions hrangle leftrightarrow rrangle are induced with so-called Rydberg pulses, and Rydberg interaction, which prohibits two neighboring atoms to both occupy Rydberg levels, can be used to generate entanglement between the atoms.","category":"page"},{"location":"examples/CZ2.html","page":"CZ","title":"CZ","text":"Here we set grangle equiv 1rangle, hrangle equiv 2rangle, and rrangle equiv 3rangle. Hamiltonian of two Rydberg atoms can then be written as","category":"page"},{"location":"examples/CZ2.html","page":"CZ","title":"CZ","text":"H = fracOmega(t)2lefte^ivarphi(t) left(sigma_+^(1) + sigma_+^(2)right) +  e^-ivarphi(t) left(sigma_-^(1) + sigma_-^(2)right)right - Delta(t) (n_1 + n_2) + V n_1n_2","category":"page"},{"location":"examples/CZ2.html","page":"CZ","title":"CZ","text":"where sigma^(i)_+ = 3ranglelangle2_i, sigma^(i)_- = 2ranglelangle3_i,  n_i = 3ranglelangle3_i and V is the Rydberg interaction strength.","category":"page"},{"location":"examples/CZ2.html","page":"CZ","title":"CZ","text":"The usual technique to realize a CZ gate (see Levine et al.) consists of shining two Rydberg pulses with a phase jump in between them. The required phase jump, pulse duration and detuning can be analytically calculated from the Rabi frequency of the Rydberg pulse. ","category":"page"},{"location":"examples/CZ2.html","page":"CZ","title":"CZ","text":"In this notebook, we find a single Rydberg pulse profile to do a CZ gate.","category":"page"},{"location":"examples/CZ2.html","page":"CZ","title":"CZ","text":"using Sisyphus\nusing QuantumOptics\nusing Flux, DiffEqFlux\nusing Plots\nusing Random\nusing ProgressMeter\n\nProgressMeter.ijulia_behavior(:clear)","category":"page"},{"location":"examples/CZ2.html","page":"CZ","title":"CZ","text":"Since pulses are required to be real-valued, we have to rewrite the Hamiltonian","category":"page"},{"location":"examples/CZ2.html","page":"CZ","title":"CZ","text":"H = Vn_1n_2 - Delta(t)(n_1 + n_2) + fracOmega(t)cosvarphi(t)2left(sigma^(1)_x + sigma^(2)_xright) + fracOmega(t)sinvarphi(t)2left(sigma^(1)_y + sigma^(2)_yright)","category":"page"},{"location":"examples/CZ2.html","page":"CZ","title":"CZ","text":"V = 2π*10.0 # MHz\n\nbs = NLevelBasis(3)\nbsys = bs⊗bs\n\nid = identityoperator(bs)\nsp1 = transition(bs, 3, 2)⊗id\nsm1 = transition(bs, 2, 3)⊗id\nsp2 = id⊗transition(bs, 3, 2)\nsm2 = id⊗transition(bs, 2, 3)\nn1 = transition(bs, 3, 3)⊗id\nn2 = id⊗transition(bs, 3, 3)\n\nH0 = V*n1*n2\nH1 = (n1 + n2)\nH2 = (sp1 + sp2 + sm1 + sm2)\nH3 = 1.0im*(sp1 + sp2 - sm1 - sm2)","category":"page"},{"location":"examples/CZ2.html","page":"CZ","title":"CZ","text":"states= [nlevelstate(bs, 1)⊗nlevelstate(bs, 1),\n         nlevelstate(bs, 1)⊗nlevelstate(bs, 2),\n         nlevelstate(bs, 2)⊗nlevelstate(bs, 1),\n         nlevelstate(bs, 2)⊗nlevelstate(bs, 2)]\n\ntrans = UnitaryTransform(states, [[1.0 0 0 0 ];[0 1.0 0 0 ];[0 0 1.0 0 ]; [0 0 0 -1.0]])","category":"page"},{"location":"examples/CZ2.html","page":"CZ","title":"CZ","text":"t0, t1 = 0.0, 1.0 # in μs\nΩ(p, t) = piecewise_const_interp(p[begin:length(p)÷3], t; t0=t0, t1=t1)\nΔ(p, t) = piecewise_const_interp(p[length(p)÷3+1:2*length(p)÷3], t; t0=t0, t1=t1)\nφ(p, t) = piecewise_const_interp(p[2*length(p)÷3+1:end], t; t0=t0, t1=t1)\n\nθ = vcat(2π * ones(10), 2π * ones(10), zeros(6), π * ones(6))\nprintln(\"Number of parameters: \", length(θ))","category":"page"},{"location":"examples/CZ2.html","page":"CZ","title":"CZ","text":"Number of parameters: 32","category":"page"},{"location":"examples/CZ2.html","page":"CZ","title":"CZ","text":"green = theme_palette(:auto).colors.colors[3]\n\nts = t0:t1/1000:t1\nplot(ts, [Ω(θ, t) for t in ts], label=\"Ω/2π\")\nplot!(ts, [Δ(θ, t) for t in ts], label=\"Δ/2π\")\nylabel!(\"Waveform (MHz)\")\nplot!(Plots.twinx(), ts, [φ(θ, t) for t in ts], ylabel=\"ϕ (Radians)\", color=green,\n      yguidefont = font(green), legend=false)\nxlabel!(\"Time (µs)\", right_margin = 15Plots.mm)","category":"page"},{"location":"examples/CZ2.html","page":"CZ","title":"CZ","text":"(Image: svg)","category":"page"},{"location":"examples/CZ2.html","page":"CZ","title":"CZ","text":"We use (x, y) -> 1.0 - real(x'*y) as a cost function since it takes into account proper phases of final states.","category":"page"},{"location":"examples/CZ2.html","page":"CZ","title":"CZ","text":"coeffs(p, t) = [-Δ(p, t), Ω(p, t) * cos(φ(p, t)) / 2, Ω(p, t) * sin(φ(p, t)) / 2]\ncost = CostFunction((x, y) -> 1.0 - real(x'*y))\nH = Hamiltonian(H0, [H1, H2, H3], coeffs)\n\nprob = QOCProblem(H, trans, (t0, t1), cost)\nsol = solve(prob, θ, Adam(0.1); maxiter=150, abstol=1e-6, reltol=1e-6)","category":"page"},{"location":"examples/CZ2.html","page":"CZ","title":"CZ","text":"\u001b[32mProgress: 100%|█████████████████████████████████████████| Time: 0:06:18\u001b[39m\r\n\u001b[34m  distance:     8.055867831952002e-5\u001b[39m\r\n\u001b[34m  constraints:  0.0\u001b[39m","category":"page"},{"location":"examples/CZ2.html","page":"CZ","title":"CZ","text":"plot(ts, [Ω(sol.params, t) for t in ts], label=\"Ω/2π\")\nplot!(ts, [Δ(sol.params, t) for t in ts], label=\"Δ/2π\")\nylabel!(\"Waveform (MHz)\")\nplot!(Plots.twinx(), ts, [φ(sol.params, t) for t in ts], ylabel=\"ϕ (Radians)\", color=green,\n      yguidefont = font(green), legend=false)\nxlabel!(\"Time (µs)\", right_margin = 15Plots.mm)","category":"page"},{"location":"examples/CZ2.html","page":"CZ","title":"CZ","text":"(Image: svg)","category":"page"},{"location":"examples/CZ2.html","page":"CZ","title":"CZ","text":"tout, psit22 = schroedinger_dynamic(ts, nlevelstate(bs, 2)⊗nlevelstate(bs, 2), H, sol.params)\ntout, psit21 = schroedinger_dynamic(ts, nlevelstate(bs, 2)⊗nlevelstate(bs, 1), H, sol.params)\ntout, psit12 = schroedinger_dynamic(ts, nlevelstate(bs, 1)⊗nlevelstate(bs, 2), H, sol.params)\ntout, psit11 = schroedinger_dynamic(ts, nlevelstate(bs, 1)⊗nlevelstate(bs, 1), H, sol.params)\n\nplot(tout, [real((nlevelstate(bs, 2)⊗nlevelstate(bs, 2))'*elm) for elm in psit22], label=\"|hh⟩\")\nplot!(tout, [real((nlevelstate(bs, 2)⊗nlevelstate(bs, 1))'*elm) for elm in psit21], label=\"|hg⟩\")\nplot!(tout, [real((nlevelstate(bs, 1)⊗nlevelstate(bs, 2))'*elm) for elm in psit12], label=\"|gh⟩\")\nplot!(tout, [real((nlevelstate(bs, 1)⊗nlevelstate(bs, 1))'*elm) for elm in psit11], label=\"|gg⟩\")\nplot!(xlabel=\"Time (µs)\", ylabel=\"Overlap (⟨ij|ψ⟩)\", legend=:right)","category":"page"},{"location":"examples/CZ2.html","page":"CZ","title":"CZ","text":"(Image: svg)","category":"page"},{"location":"installation.html#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation.html","page":"Installation","title":"Installation","text":"You can install Sisyphus.jl and it's dependencies in the REPL (press ] to enter the Pkg mode) with","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"pkg> add https://github.com/entropy-lab/Sisyphus.git","category":"page"},{"location":"examples/GHZStateCUDAPiecewiseConstInterp.html#GHZ-state-in-Rydberg-atoms-(CUDA)","page":"GHZ state in Rydberg atoms (CUDA)","title":"GHZ state in Rydberg atoms (CUDA)","text":"","category":"section"},{"location":"examples/GHZStateCUDAPiecewiseConstInterp.html","page":"GHZ state in Rydberg atoms (CUDA)","title":"GHZ state in Rydberg atoms (CUDA)","text":"using Sisyphus\nusing QuantumOptics\nusing LinearAlgebra\nusing Flux, DiffEqFlux\nusing Plots\nusing ProgressMeter\nusing Random\nProgressMeter.ijulia_behavior(:clear)","category":"page"},{"location":"examples/GHZStateCUDAPiecewiseConstInterp.html","page":"GHZ state in Rydberg atoms (CUDA)","title":"GHZ state in Rydberg atoms (CUDA)","text":"false","category":"page"},{"location":"examples/GHZStateCUDAPiecewiseConstInterp.html","page":"GHZ state in Rydberg atoms (CUDA)","title":"GHZ state in Rydberg atoms (CUDA)","text":"bs = SpinBasis(1//2)\nsx = sigmax(bs)\nni = 0.5*(identityoperator(bs) + sigmaz(bs))","category":"page"},{"location":"examples/GHZStateCUDAPiecewiseConstInterp.html","page":"GHZ state in Rydberg atoms (CUDA)","title":"GHZ state in Rydberg atoms (CUDA)","text":"V = 2π*24.0\nδe = -2π*4.5","category":"page"},{"location":"examples/GHZStateCUDAPiecewiseConstInterp.html","page":"GHZ state in Rydberg atoms (CUDA)","title":"GHZ state in Rydberg atoms (CUDA)","text":"-28.274333882308138","category":"page"},{"location":"examples/GHZStateCUDAPiecewiseConstInterp.html","page":"GHZ state in Rydberg atoms (CUDA)","title":"GHZ state in Rydberg atoms (CUDA)","text":"n_atoms = 16\nbsys = tensor([bs for i in 1:n_atoms]...)\n\nH0 = V*sum([embed(bsys, [i, j], [ni, ni])/abs(i-j)^6  for i in 1:n_atoms for j in i+1:n_atoms])\nH0 -= δe*sum([embed(bsys, [i], [ni]) for i in [1, n_atoms]])\nif n_atoms>8\n    H0 -= -2π*1.5*sum([embed(bsys, [i], [ni]) for i in [1, n_atoms]])\n    H0 -= -2π*1.5*sum([embed(bsys, [i], [ni]) for i in [4, n_atoms-3]])\nend;\n\nH1 = 0.5*sum([embed(bsys, [i], [sx]) for i in 1:n_atoms])\nH2 = -sum([embed(bsys, [i], [ni]) for i in 1:n_atoms])","category":"page"},{"location":"examples/GHZStateCUDAPiecewiseConstInterp.html","page":"GHZ state in Rydberg atoms (CUDA)","title":"GHZ state in Rydberg atoms (CUDA)","text":"function GHZ_state(n_atoms)\n    state = tensor([spindown(bs)⊗spinup(bs) for i in 1:Int(n_atoms/2)]...) +\n            tensor([spinup(bs)⊗spindown(bs) for i in 1:Int(n_atoms/2)]...)\n    state/sqrt(2.0)\nend \n\nground_state(n_atoms) = tensor([spindown(bs) for i in 1:n_atoms]...)\ntrans = StateTransform(ground_state(n_atoms)=>GHZ_state(n_atoms))","category":"page"},{"location":"examples/GHZStateCUDAPiecewiseConstInterp.html","page":"GHZ state in Rydberg atoms (CUDA)","title":"GHZ state in Rydberg atoms (CUDA)","text":"T = 1.1f0\nΩ₀(t) = 2.f0π * min(5, 25 * t / T, 25 * (T - t) / T)","category":"page"},{"location":"examples/GHZStateCUDAPiecewiseConstInterp.html","page":"GHZ state in Rydberg atoms (CUDA)","title":"GHZ state in Rydberg atoms (CUDA)","text":"Ω₀ (generic function with 1 method)","category":"page"},{"location":"examples/GHZStateCUDAPiecewiseConstInterp.html","page":"GHZ state in Rydberg atoms (CUDA)","title":"GHZ state in Rydberg atoms (CUDA)","text":"Ω(p, t) = piecewise_const_interp(p[begin:length(p)-2], t; t0=0.f0, t1=T)\nΔ(p, t) = p[end-1]*t + p[end]\n\nn_params = 20\nts = 0:T/(n_params-2):T\nθ = (vcat([Ω₀((ts[i+1] + ts[i])/2) for i=1:n_params-2], 2.f0π*[30/T, -15]))","category":"page"},{"location":"examples/GHZStateCUDAPiecewiseConstInterp.html","page":"GHZ state in Rydberg atoms (CUDA)","title":"GHZ state in Rydberg atoms (CUDA)","text":"ts = 0:T/1000:T\n\nblue = theme_palette(:auto).colors.colors[1]\nred = theme_palette(:auto).colors.colors[2]\nplot(ts, [Δ(θ, t)/2π for t in ts], ylabel=\"Δ/2π (MHz)\", color=blue, yguidefont = font(blue), legend=false)\nplot!(Plots.twinx(), ts, [Ω(θ, t)/2π for t in ts], ylabel=\"Ω/2π (MHz)\", color=red, yguidefont = font(red), legend=false)\nplot!(xlabel=\"time (μs)\", right_margin = 15Plots.mm)","category":"page"},{"location":"examples/GHZStateCUDAPiecewiseConstInterp.html","page":"GHZ state in Rydberg atoms (CUDA)","title":"GHZ state in Rydberg atoms (CUDA)","text":"(Image: svg)","category":"page"},{"location":"examples/GHZStateCUDAPiecewiseConstInterp.html","page":"GHZ state in Rydberg atoms (CUDA)","title":"GHZ state in Rydberg atoms (CUDA)","text":"cost = CostFunction((x, y) -> 1.0f0 - abs2(sum(conj(x).*y)))","category":"page"},{"location":"examples/GHZStateCUDAPiecewiseConstInterp.html","page":"GHZ state in Rydberg atoms (CUDA)","title":"GHZ state in Rydberg atoms (CUDA)","text":"CostFunction(var\"#29#30\"(), nothing)","category":"page"},{"location":"examples/GHZStateCUDAPiecewiseConstInterp.html","page":"GHZ state in Rydberg atoms (CUDA)","title":"GHZ state in Rydberg atoms (CUDA)","text":"H = Hamiltonian(H0, [H1, H2], (p, t) -> [Ω(p, t), Δ(p, t)])","category":"page"},{"location":"examples/GHZStateCUDAPiecewiseConstInterp.html","page":"GHZ state in Rydberg atoms (CUDA)","title":"GHZ state in Rydberg atoms (CUDA)","text":"prob = cu(convert(Float32, QOCProblem(H, trans, (0.0, Float64(T)), cost)))","category":"page"},{"location":"examples/GHZStateCUDAPiecewiseConstInterp.html","page":"GHZ state in Rydberg atoms (CUDA)","title":"GHZ state in Rydberg atoms (CUDA)","text":"@time sol = solve(prob, Vector{Float32}(θ), Adam(0.5f0); maxiter=60, abstol=1e-5, reltol=1e-5)","category":"page"},{"location":"examples/GHZStateCUDAPiecewiseConstInterp.html","page":"GHZ state in Rydberg atoms (CUDA)","title":"GHZ state in Rydberg atoms (CUDA)","text":"\u001b[32mProgress: 100%|█████████████████████████████████████████| Time: 1:04:55\u001b[39m\r\n\u001b[34m  distance:     0.14893913\u001b[39m\r\n\u001b[34m  constraints:  0.0\u001b[39m\n\n\n3943.376298 seconds (2.47 G allocations: 82.475 GiB, 1.34% gc time, 2.37% compilation time)\n\n\n\n\n\nSolution{Float32}(Float32[8.132387, 6.254851, 16.87701, 27.292034, 38.762474, 35.514427, 32.840717, 35.747673, 26.317242, 31.769138, 26.352428, 28.457672, 31.089022, 35.126503, 37.837715, 33.345055, 20.531998, 11.850042, 160.635, -85.93381], Float32[0.38781625, 0.3351711, 0.29689872, 0.27643716, 0.26351196, 0.25058532, 0.24053651, 0.23353988, 0.22954822, 0.22459096  …  0.15819484, 0.1571632, 0.15608937, 0.15436864, 0.15362132, 0.15257686, 0.1519208, 0.14995301, 0.14944446, 0.14893913], Float32[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], Vector{Float32}[])","category":"page"},{"location":"examples/GHZStateCUDAPiecewiseConstInterp.html","page":"GHZ state in Rydberg atoms (CUDA)","title":"GHZ state in Rydberg atoms (CUDA)","text":"plot(sol.distance_trace)","category":"page"},{"location":"examples/GHZStateCUDAPiecewiseConstInterp.html","page":"GHZ state in Rydberg atoms (CUDA)","title":"GHZ state in Rydberg atoms (CUDA)","text":"(Image: svg)","category":"page"},{"location":"examples/GHZStateCUDAPiecewiseConstInterp.html","page":"GHZ state in Rydberg atoms (CUDA)","title":"GHZ state in Rydberg atoms (CUDA)","text":"blue = theme_palette(:auto).colors.colors[1]\nred = theme_palette(:auto).colors.colors[2]\nplot(ts, [Δ(sol.params, t)/2π for t in ts], ylabel=\"Δ/2π (MHz)\",\n     color=blue, yguidefont = font(blue), legend=false)\nplot!(Plots.twinx(), ts, [Ω(sol.params, t)/2π for t in ts],\n     ylabel=\"Ω/2π (MHz)\", color=red, yguidefont = font(red), legend=false)\nplot!(xlabel=\"time (μs)\", right_margin = 15Plots.mm)","category":"page"},{"location":"examples/GHZStateCUDAPiecewiseConstInterp.html","page":"GHZ state in Rydberg atoms (CUDA)","title":"GHZ state in Rydberg atoms (CUDA)","text":"(Image: svg)","category":"page"},{"location":"examples/GHZStateCUDALinearInterp.html#GHZ-state-in-Rydberg-atoms-(CUDA)","page":"GHZ state 16 atoms (CUDA)","title":"GHZ state in Rydberg atoms (CUDA)","text":"","category":"section"},{"location":"examples/GHZStateCUDALinearInterp.html","page":"GHZ state 16 atoms (CUDA)","title":"GHZ state 16 atoms (CUDA)","text":"using Sisyphus\nusing QuantumOptics\nusing LinearAlgebra\nusing Flux, DiffEqFlux\nusing Plots\nusing ProgressMeter\nusing Random\nProgressMeter.ijulia_behavior(:clear)","category":"page"},{"location":"examples/GHZStateCUDALinearInterp.html","page":"GHZ state 16 atoms (CUDA)","title":"GHZ state 16 atoms (CUDA)","text":"false","category":"page"},{"location":"examples/GHZStateCUDALinearInterp.html","page":"GHZ state 16 atoms (CUDA)","title":"GHZ state 16 atoms (CUDA)","text":"bs = SpinBasis(1//2)\nsx = sigmax(bs)\nni = 0.5*(identityoperator(bs) + sigmaz(bs))","category":"page"},{"location":"examples/GHZStateCUDALinearInterp.html","page":"GHZ state 16 atoms (CUDA)","title":"GHZ state 16 atoms (CUDA)","text":"V = 2π*24.0\nδe = -2π*4.5","category":"page"},{"location":"examples/GHZStateCUDALinearInterp.html","page":"GHZ state 16 atoms (CUDA)","title":"GHZ state 16 atoms (CUDA)","text":"-28.274333882308138","category":"page"},{"location":"examples/GHZStateCUDALinearInterp.html","page":"GHZ state 16 atoms (CUDA)","title":"GHZ state 16 atoms (CUDA)","text":"n_atoms = 16\nbsys = tensor([bs for i in 1:n_atoms]...)\n\nH0 = V*sum([embed(bsys, [i, j], [ni, ni])/abs(i-j)^6  for i in 1:n_atoms for j in i+1:n_atoms])\nH0 -= δe*sum([embed(bsys, [i], [ni]) for i in [1, n_atoms]])\nif n_atoms>8\n    H0 -= -2π*1.5*sum([embed(bsys, [i], [ni]) for i in [1, n_atoms]])\n    H0 -= -2π*1.5*sum([embed(bsys, [i], [ni]) for i in [4, n_atoms-3]])\nend;\n\nH1 = 0.5*sum([embed(bsys, [i], [sx]) for i in 1:n_atoms])\nH2 = -sum([embed(bsys, [i], [ni]) for i in 1:n_atoms])","category":"page"},{"location":"examples/GHZStateCUDALinearInterp.html","page":"GHZ state 16 atoms (CUDA)","title":"GHZ state 16 atoms (CUDA)","text":"function GHZ_state(n_atoms)\n    state = tensor([spindown(bs)⊗spinup(bs) for i in 1:Int(n_atoms/2)]...) +\n            tensor([spinup(bs)⊗spindown(bs) for i in 1:Int(n_atoms/2)]...)\n    state/sqrt(2.0)\nend \n\nground_state(n_atoms) = tensor([spindown(bs) for i in 1:n_atoms]...)\ntrans = StateTransform(ground_state(n_atoms)=>GHZ_state(n_atoms))","category":"page"},{"location":"examples/GHZStateCUDALinearInterp.html","page":"GHZ state 16 atoms (CUDA)","title":"GHZ state 16 atoms (CUDA)","text":"T = 1.1f0\nΩ₀(t) = 2.f0π * min(5, 25 * t / T, 25 * (T - t) / T)","category":"page"},{"location":"examples/GHZStateCUDALinearInterp.html","page":"GHZ state 16 atoms (CUDA)","title":"GHZ state 16 atoms (CUDA)","text":"Ω₀ (generic function with 1 method)","category":"page"},{"location":"examples/GHZStateCUDALinearInterp.html","page":"GHZ state 16 atoms (CUDA)","title":"GHZ state 16 atoms (CUDA)","text":"Ω(p, t) = linear_interp(p[begin:length(p)-2], t; t0=0.f0, t1=T)\nΔ(p, t) = p[end-1]*t + p[end]\n\nn_params = 20\nts = 0:T/(n_params-2):T\nθ = (vcat([Ω₀((ts[i+1] + ts[i])/2) for i=1:n_params-2], 2.f0π*[30/T, -15]))","category":"page"},{"location":"examples/GHZStateCUDALinearInterp.html","page":"GHZ state 16 atoms (CUDA)","title":"GHZ state 16 atoms (CUDA)","text":"ts = 0:T/1000:T\n\nblue = theme_palette(:auto).colors.colors[1]\nred = theme_palette(:auto).colors.colors[2]\nplot(ts, [Δ(θ, t)/2π for t in ts], ylabel=\"Δ/2π (MHz)\", color=blue, yguidefont = font(blue), legend=false)\nplot!(Plots.twinx(), ts, [Ω(θ, t)/2π for t in ts], ylabel=\"Ω/2π (MHz)\", color=red, yguidefont = font(red), legend=false)\nplot!(xlabel=\"time (μs)\", right_margin = 15Plots.mm)","category":"page"},{"location":"examples/GHZStateCUDALinearInterp.html","page":"GHZ state 16 atoms (CUDA)","title":"GHZ state 16 atoms (CUDA)","text":"(Image: svg)","category":"page"},{"location":"examples/GHZStateCUDALinearInterp.html","page":"GHZ state 16 atoms (CUDA)","title":"GHZ state 16 atoms (CUDA)","text":"cost = CostFunction((x, y) -> 1.0f0 - abs2(sum(conj(x).*y)))","category":"page"},{"location":"examples/GHZStateCUDALinearInterp.html","page":"GHZ state 16 atoms (CUDA)","title":"GHZ state 16 atoms (CUDA)","text":"CostFunction(var\"#29#30\"(), nothing)","category":"page"},{"location":"examples/GHZStateCUDALinearInterp.html","page":"GHZ state 16 atoms (CUDA)","title":"GHZ state 16 atoms (CUDA)","text":"H = Hamiltonian(H0, [H1, H2], (p, t) -> [Ω(p, t), Δ(p, t)])","category":"page"},{"location":"examples/GHZStateCUDALinearInterp.html","page":"GHZ state 16 atoms (CUDA)","title":"GHZ state 16 atoms (CUDA)","text":"prob = cu(convert(Float32, QOCProblem(H, trans, (0.0, Float64(T)), cost)))","category":"page"},{"location":"examples/GHZStateCUDALinearInterp.html","page":"GHZ state 16 atoms (CUDA)","title":"GHZ state 16 atoms (CUDA)","text":"@time sol = solve(prob, Vector{Float32}(θ), Adam(0.5f0); maxiter=60, abstol=1e-5, reltol=1e-5)","category":"page"},{"location":"examples/GHZStateCUDALinearInterp.html","page":"GHZ state 16 atoms (CUDA)","title":"GHZ state 16 atoms (CUDA)","text":"\u001b[32mProgress: 100%|█████████████████████████████████████████| Time: 1:01:59\u001b[39m\r\n\u001b[34m  distance:     0.048260212\u001b[39m\r\n\u001b[34m  constraints:  0.0\u001b[39m\n\n\n3767.799382 seconds (3.43 G allocations: 137.427 GiB, 1.61% gc time, 2.55% compilation time)\n\n\n\n\n\nSolution{Float32}(Float32[-1.7573144, 6.2717557, 33.9015, 30.158419, 39.08852, 34.057602, 43.074272, 42.70463, 40.99229, 37.020718, 32.745403, 33.47515, 38.1225, 40.853737, 38.02665, 34.68313, 31.695887, 1.7749814, 176.89078, -86.49249], Float32[0.3014481, 0.2640503, 0.24152261, 0.22818756, 0.2156403, 0.20196182, 0.18877274, 0.17788285, 0.16937923, 0.16154522  …  0.058342993, 0.056429923, 0.055140913, 0.05356592, 0.052268267, 0.050708175, 0.049109757, 0.04851371, 0.048073173, 0.048260212], Float32[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], Vector{Float32}[])","category":"page"},{"location":"examples/GHZStateCUDALinearInterp.html","page":"GHZ state 16 atoms (CUDA)","title":"GHZ state 16 atoms (CUDA)","text":"plot(sol.distance_trace)","category":"page"},{"location":"examples/GHZStateCUDALinearInterp.html","page":"GHZ state 16 atoms (CUDA)","title":"GHZ state 16 atoms (CUDA)","text":"(Image: svg)","category":"page"},{"location":"examples/GHZStateCUDALinearInterp.html","page":"GHZ state 16 atoms (CUDA)","title":"GHZ state 16 atoms (CUDA)","text":"blue = theme_palette(:auto).colors.colors[1]\nred = theme_palette(:auto).colors.colors[2]\nplot(ts, [Δ(sol.params, t)/2π for t in ts], ylabel=\"Δ/2π (MHz)\",\n     color=blue, yguidefont = font(blue), legend=false)\nplot!(Plots.twinx(), ts, [Ω(sol.params, t)/2π for t in ts],\n     ylabel=\"Ω/2π (MHz)\", color=red, yguidefont = font(red), legend=false)\nplot!(xlabel=\"time (μs)\", right_margin = 15Plots.mm)","category":"page"},{"location":"examples/GHZStateCUDALinearInterp.html","page":"GHZ state 16 atoms (CUDA)","title":"GHZ state 16 atoms (CUDA)","text":"(Image: svg)","category":"page"},{"location":"gbqoc.html#Gradient-based-quantum-optimal-control","page":"Gradient-based QOC","title":"Gradient-based quantum optimal control","text":"","category":"section"},{"location":"gbqoc.html","page":"Gradient-based QOC","title":"Gradient-based QOC","text":"In this section, we describe in detail the optimization algorithm implemented in Sisyphus.jl.","category":"page"},{"location":"gbqoc.html","page":"Gradient-based QOC","title":"Gradient-based QOC","text":"A general QOC problem aims to find time-dependent control knobs to simultaneously guide the evolution of a given set of input states to some chosen target states subject to physical and hardware constraints. Let us denote the input and target states of the problem psi^(1)_irangle psi^(2)_irangle dots psi^(N)_irangle and psi^(1)_frangle psi^(2)_frangle dots psi^(N)_frangle respectively. Without loss of generality, the time-dependent Hamiltonian governing the dynamics of a quantum system can be written as,","category":"page"},{"location":"gbqoc.html","page":"Gradient-based QOC","title":"Gradient-based QOC","text":"H(t) = H_0 + H_c(t) = H_0 + sum_m=1^M c_m(t) H_m","category":"page"},{"location":"gbqoc.html","page":"Gradient-based QOC","title":"Gradient-based QOC","text":"The control drives c_1(t) c_2(t) dots c_M(t) define the unitary transformation:","category":"page"},{"location":"gbqoc.html","page":"Gradient-based QOC","title":"Gradient-based QOC","text":"U(c_m T) = e^-i int_0^T H(t) mathrmdt","category":"page"},{"location":"gbqoc.html","page":"Gradient-based QOC","title":"Gradient-based QOC","text":"The drives c_k(t) are designed by optimizing a certain cost function. In practice, the cost function is chosen to reflect the quality of the desired transformation and by constraining the pulses:","category":"page"},{"location":"gbqoc.html","page":"Gradient-based QOC","title":"Gradient-based QOC","text":"C(c_m) = frac1Nsum_j=1^N  d(psi^(j)_frangle U(c_m T)psi^(j)_irangle) + F(c_m(t))","category":"page"},{"location":"gbqoc.html","page":"Gradient-based QOC","title":"Gradient-based QOC","text":"where d(psi^(j)_frangle U(c_m T)psi^(j)_irangle) is some distance measure and F takes into account the experimental constraints such as bounds on control signals, finite bandwidth and power etc. The gradient of the cost function wrt the parameters is,","category":"page"},{"location":"gbqoc.html","page":"Gradient-based QOC","title":"Gradient-based QOC","text":"fracpartial C(c_m)partial w_k = frac1Nsum_j=1^N fracpartialpartial w_kdleft(psi^(j)_frangle psi^(j)(T)rangleright) + fracpartial Fpartial w_k","category":"page"},{"location":"gbqoc.html","page":"Gradient-based QOC","title":"Gradient-based QOC","text":"where psi^(j)(T)rangle = U(c_m T)psi^(j)_irangle and w_k parameterize the control signals c_m. The second term in the above equation can be evaluated with standard AD techniques. The first term can be efficiently calculated without propagating the derivative through the ODE solver using the adjoint sensitivity method. We have,","category":"page"},{"location":"gbqoc.html","page":"Gradient-based QOC","title":"Gradient-based QOC","text":"fracpartialpartial w_kdleft(psi^(j)_frangle psi^(j)(T)rangleright) = fracpartial d(xy)partial y Big_x=psi^(j)_frangle y = psi^(j)(T)rangle fracpartialpsi^(j)(T)ranglepartial w_k","category":"page"},{"location":"gbqoc.html","page":"Gradient-based QOC","title":"Gradient-based QOC","text":"Therefore, the gradient partial C(c_m)partial w_k can be computed from psi^(j)(T)rangle and partialpsi^(j)(T)rangle partial w_k. For a closed quantum system, we get the following augmented system of equations,","category":"page"},{"location":"gbqoc.html","page":"Gradient-based QOC","title":"Gradient-based QOC","text":"fracmathrmdpsi^(j)ranglemathrmdt = -i H(t) psi^(j)rangle","category":"page"},{"location":"gbqoc.html","page":"Gradient-based QOC","title":"Gradient-based QOC","text":"fracmathrmdmathrmdt fracpartialpsi^(j)ranglepartial w_k = -ileftH(t) fracpartialpsi^(j)ranglepartial w_k + sum_m=1^Mfracpartial c_m(t)partial w_k H_m psi^(j)rangleright","category":"page"},{"location":"gbqoc.html","page":"Gradient-based QOC","title":"Gradient-based QOC","text":"with initial conditions psi^(j)(0)rangle = psi^(j)_irangle and partialpsi^(j)(0)ranglepartial w_k = 0.","category":"page"},{"location":"gbqoc.html","page":"Gradient-based QOC","title":"Gradient-based QOC","text":"These coupled equations can be solved using a higher-order ODE solver and gradients wrt the parameters can be evaluated to the desired numerical accuracy. For a given set of parameters, knowing the cost function and the gradients, one could then use any gradient based optimization method to iteratively update the parameters, until a satisfactory solution is found.","category":"page"},{"location":"gbqoc.html","page":"Gradient-based QOC","title":"Gradient-based QOC","text":"Note that the algorithm presented here is quite similar to GOAT, except that the equations we solve are expressed only in terms of states instead of the evolution operator. Therefore, effectively Sisyphus.jl requires less memory compared to GOAT!","category":"page"},{"location":"gbqoc.html","page":"Gradient-based QOC","title":"Gradient-based QOC","text":"(Image: Schematic diagram of gradient-based optimal control)","category":"page"},{"location":"api.html#API","page":"API","title":"API","text":"","category":"section"},{"location":"api.html#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"Hamiltonian","category":"page"},{"location":"api.html#Sisyphus.Hamiltonian","page":"API","title":"Sisyphus.Hamiltonian","text":"Hamiltonian(const_op::op,\n            ops::Vector{op}),\n            drives::Function) where {op<:AbstractOperator}\n\nStructure to represent a time-dependent Hamiltonian.\n\nNOTE: Drives are required to be real-valued functions and should be of the form       drives(p::Vector{T}, t::T) where {T<:Real}, where p is a vector of real values parametrizing       the control knobs and t is the time.\n\n\n\n\n\n","category":"type"},{"location":"api.html","page":"API","title":"API","text":"Transform","category":"page"},{"location":"api.html#Sisyphus.Transform","page":"API","title":"Sisyphus.Transform","text":"Abstract base class for transformations between states.\n\n\n\n\n\n","category":"type"},{"location":"api.html","page":"API","title":"API","text":"StateTransform","category":"page"},{"location":"api.html#Sisyphus.StateTransform","page":"API","title":"Sisyphus.StateTransform","text":"StateTransform(input::Ket{B,T}, output::Ket{B,T}) where {B, T}\n\nRepresents a state to state transformation between two pure states.\n\n\n\n\n\n","category":"type"},{"location":"api.html","page":"API","title":"API","text":"UnitaryTransform","category":"page"},{"location":"api.html#Sisyphus.UnitaryTransform","page":"API","title":"Sisyphus.UnitaryTransform","text":"UnitaryTransform(inputs::Vector{Ket{B, T}}, U::Matrix) where {B, T}\n\nRepresents a unitary transformation between two sets of states. The tranformation can be initialized with a vector of kets and a unitary matrix representing the desired transformation.\n\n\n\n\n\n","category":"type"},{"location":"api.html","page":"API","title":"API","text":"CostFunction","category":"page"},{"location":"api.html#Sisyphus.CostFunction","page":"API","title":"Sisyphus.CostFunction","text":"CostFunction(distance, constraints)\n\nDefines a cost function used for optimization.\n\nArguments\n\ndistance denotes a distance measure between quantum states, it should be a real valued function for e.g. d(x,y) = 1 - real(x'*y) where x and y are two complex valued vectors.\n\nconstraints (optional) denotes the constraints on the shapes of pulses, it should be a real valued function\n\nNOTE: During the optimization we minimize the total cost given by the sum of average distance (considering all states in the transform) evaluated for a given set of parameters and the constraints. i.e. d(x,y) + constraints(params).\n\n\n\n\n\n","category":"type"},{"location":"api.html","page":"API","title":"API","text":"QOCProblem","category":"page"},{"location":"api.html#Sisyphus.QOCProblem","page":"API","title":"Sisyphus.QOCProblem","text":"QOCProblem(hamiltonian::Hamiltonian{T},\n           transform::Transform,\n           tspan::Tuple{T,T}},\n           cost::CostFunction) where {T<:Real}\n\nDefines a quantum optimal control problem to be solved.\n\n\n\n\n\n","category":"type"},{"location":"api.html","page":"API","title":"API","text":"AdjointSolver","category":"page"},{"location":"api.html#Sisyphus.AdjointSolver","page":"API","title":"Sisyphus.AdjointSolver","text":"AdjointSolver\n\nSolver to evaluate gradients by solving the coupled equations, defined for compatibility with CommonSolve interface.\n\n\n\n\n\n","category":"type"},{"location":"api.html","page":"API","title":"API","text":"Solution","category":"page"},{"location":"api.html#Sisyphus.Solution","page":"API","title":"Sisyphus.Solution","text":"Solution(params)\n\nContains the optimized parameters after solving the QOCProblem. It also contains traces of distance and constraints specified in the CostFunction. Optionally, it contains the full trace of parameters.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Functions","page":"API","title":"Functions","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"schroedinger_dynamic","category":"page"},{"location":"api.html#Sisyphus.schroedinger_dynamic","page":"API","title":"Sisyphus.schroedinger_dynamic","text":"schroedinger_dynamic(tspan, psi, h, params; kwargs)\n\nWraps schroedinger_dynamic from QuantumOptics by accepting our custom  Hamiltonian structure and the parameters.\n\n\n\n\n\n","category":"function"},{"location":"api.html","page":"API","title":"API","text":"master_dynamic","category":"page"},{"location":"api.html#Sisyphus.master_dynamic","page":"API","title":"Sisyphus.master_dynamic","text":"master_dynamic(tspan, psi, h, params, J, rates; kwargs)\n\nWraps master_dynamic from QuantumOptics by accepting our custom  Hamiltonian structure and the parameters.\n\n\n\n\n\n","category":"function"},{"location":"api.html","page":"API","title":"API","text":"vectorize","category":"page"},{"location":"api.html#Sisyphus.vectorize","page":"API","title":"Sisyphus.vectorize","text":"vectorize(k::Ket)\n\nReturns a ket representing the vectorized form of the density matrix of ket k.\n\n\n\n\n\nvectorize(trans::StateTransform)\n\nReturns a vectorized form of the state to state transformation.\n\n\n\n\n\nvectorize(trans::UnitaryTransform)\n\nReturns a vectorized form of the unitary transformation.\n\n\n\n\n\nvectorize(H, J, rates)\n\nVectorizes the Hamiltonian and jump operators so that they can be submitted to the Schroedinger time evolution solver. Uses the vectorization identity textvec(ABC) = (C^T otimes A)textvec(B).\n\n\n\n\n\n","category":"function"},{"location":"api.html#Utilities","page":"API","title":"Utilities","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"heaviside","category":"page"},{"location":"api.html#Sisyphus.heaviside","page":"API","title":"Sisyphus.heaviside","text":"heaviside(t::T) where {T <: Real}\n\nHeaviside step function\n\nH(t) = \nbegincases\n    1  t  0 \n    0  t leq 0\nendcases\n\n\n\n\n\n","category":"function"},{"location":"api.html","page":"API","title":"API","text":"interval","category":"page"},{"location":"api.html#Sisyphus.interval","page":"API","title":"Sisyphus.interval","text":"interval(t::T, a::T, b::T) where {T <: Real}\n\nInterval function\n\n    I(t a b) = H(t - a) - H(t - b)\n\n\n\n\n\n","category":"function"},{"location":"api.html","page":"API","title":"API","text":"piecewise_const_interp","category":"page"},{"location":"api.html#Sisyphus.piecewise_const_interp","page":"API","title":"Sisyphus.piecewise_const_interp","text":"piecewise_const_interp(p, t; t0, t1)\n\nPiecewise constant interpolation of equidistant samples p.\n\n\n\n\n\n","category":"function"},{"location":"api.html","page":"API","title":"API","text":"linear_interp","category":"page"},{"location":"api.html#Sisyphus.linear_interp","page":"API","title":"Sisyphus.linear_interp","text":"linear_interp(p, t; t0, t1)\n\nLinear interpolation of equidistant samples p.\n\n\n\n\n\n","category":"function"},{"location":"api.html","page":"API","title":"API","text":"cubic_spline_interp","category":"page"},{"location":"api.html#Sisyphus.cubic_spline_interp","page":"API","title":"Sisyphus.cubic_spline_interp","text":"cubic_spline_interp(p, t; t0, t1)\n\nCubic spline interpolation of equidistant samples p with natural boundary conditions.\n\n\n\n\n\n","category":"function"},{"location":"api.html#GPU","page":"API","title":"GPU","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"CuKet(k::Ket)","category":"page"},{"location":"api.html#Sisyphus.CuKet-Tuple{Ket}","page":"API","title":"Sisyphus.CuKet","text":"CuKet(k::Ket)\n\nReturns a Ket with the data allocated on GPU memory.\n\n\n\n\n\n","category":"method"},{"location":"api.html","page":"API","title":"API","text":"cu","category":"page"},{"location":"api.html#CUDA.cu","page":"API","title":"CUDA.cu","text":"cu(A; unified=false)\n\nOpinionated GPU array adaptor, which may alter the element type T of arrays:\n\nFor T<:AbstractFloat, it makes a CuArray{Float32} for performance reasons. (Except that Float16 and BFloat16 element types are not changed.)\nFor T<:Complex{<:AbstractFloat} it makes a CuArray{ComplexF32}.\nFor other isbitstype(T), it makes a CuArray{T}.\n\nBy contrast, CuArray(A) never changes the element type.\n\nUses Adapt.jl to act inside some wrapper structs.\n\nExamples\n\njulia> cu(ones(3)')\n1×3 adjoint(::CuArray{Float32, 1, CUDA.Mem.DeviceBuffer}) with eltype Float32:\n 1.0  1.0  1.0\n\njulia> cu(zeros(1, 3); unified=true)\n1×3 CuArray{Float32, 2, CUDA.Mem.UnifiedBuffer}:\n 0.0  0.0  0.0\n\njulia> cu(1:3)\n1:3\n\njulia> CuArray(ones(3)')  # ignores Adjoint, preserves Float64\n1×3 CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}:\n 1.0  1.0  1.0\n\njulia> adapt(CuArray, ones(3)')  # this restores Adjoint wrapper\n1×3 adjoint(::CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}) with eltype Float64:\n 1.0  1.0  1.0\n\njulia> CuArray(1:3)\n3-element CuArray{Int64, 1, CUDA.Mem.DeviceBuffer}:\n 1\n 2\n 3\n\n\n\n\n\ncu(h::Hamiltonian)\n\nConverts the Hamiltonian with the operators allocated on GPU memory.\n\n\n\n\n\ncu(trans::UnitaryTransform)\n\nReturns a unitary transformation with the kets allocated on GPU memory.\n\n\n\n\n\ncu(trans::StateTransform)\n\nReturns a state to state transformation with the kets allocated on GPU memory.\n\n\n\n\n\ncu(prob)\n\nTurns a quantum optimal control problem into a form suitable for running on GPU.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Single-precision","page":"API","title":"Single precision","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"convert(::Type{Float32}, prob::QOCProblem)","category":"page"},{"location":"api.html#Base.convert-Tuple{Type{Float32}, QOCProblem}","page":"API","title":"Base.convert","text":"convert(::Type{Float32}, prob::QOCProblem)\n\nReturns a QOCProblem with all data in single precision.\n\n\n\n\n\n","category":"method"},{"location":"examples/RXpi2.html#R_x(\\pi/2)-gate","page":"Rₓ(π/2)","title":"R_x(pi2) gate","text":"","category":"section"},{"location":"examples/RXpi2.html","page":"Rₓ(π/2)","title":"Rₓ(π/2)","text":"using Sisyphus\nusing QuantumOptics\nusing Flux, DiffEqFlux\nusing Plots\nusing Random\nusing ProgressMeter\n\nProgressMeter.ijulia_behavior(:clear)","category":"page"},{"location":"examples/RXpi2.html","page":"Rₓ(π/2)","title":"Rₓ(π/2)","text":"A transmon is a Josephson junction (non linear inductor) shunted with a capacitor. The quantum mechanical Hamiltonian of such a system often referred to as a Cooper pair box is given,","category":"page"},{"location":"examples/RXpi2.html","page":"Rₓ(π/2)","title":"Rₓ(π/2)","text":" H = 4 E_c (n - n_g)^2 - E_J cosvarphi","category":"page"},{"location":"examples/RXpi2.html","page":"Rₓ(π/2)","title":"Rₓ(π/2)","text":"where n and varphi are the Cooper pair number and phase conjugate variables, n_g is charge bias, E_J and E_c denote the Josephson and charging energies respectively.  The non linear nature of the Josephson junction makes the transmon an anharmonic oscillator, effectively isolating the first two levels from the remaining levels to realize a qubit (i.e. omega_01neq omega_12). The evolution of transmons is modelled with a generalized Duffing Oscillator resulting from the expansion of Cooper pair box Hamiltonian,","category":"page"},{"location":"examples/RXpi2.html","page":"Rₓ(π/2)","title":"Rₓ(π/2)","text":"H_DO_K = omega_0 left(a^daggera + frac12right) +fracomega_0^28eta sum_k=2^K left(frac4etaomega_0right)^kfrac(-1)^k (a^dagger + a)^2k(2k) +  i f(t)cosomega(t)t + phi(t)(a - a^dagger) ","category":"page"},{"location":"examples/RXpi2.html","page":"Rₓ(π/2)","title":"Rₓ(π/2)","text":"where omega_0 is the qubit frequency, eta is the anharmonicity (note that omega_01 approx omega_0 + eta), f(t) is the slow varying envelope of the RF drive. The microwave frequency omega is typically in the GHz range and therefore it is generated by mixing a low frequency signal of few MHz with a local oscillator omega = omega_LO + omega_IF. The I and Q quadratures of slow varying envelope,","category":"page"},{"location":"examples/RXpi2.html","page":"Rₓ(π/2)","title":"Rₓ(π/2)","text":"I(t) Q(t) = f(t)cos(phi(t)) f(t) sin(phi(t))","category":"page"},{"location":"examples/RXpi2.html","page":"Rₓ(π/2)","title":"Rₓ(π/2)","text":"Jones et al.  argue that for typical transmon parameters, sextic terms (K=3) are enough to match the spectrum of the Cooper pair box Hamiltonian (K=infty). In general, the minimum number of levels and expansion order needed to accurately model the dynamics depends on the anharmonicity, strength of the drive etc. these parameters have to be chosen based on the desired accuracy, for e.g. by monitoring the occupation probabilities of lower energy levels.","category":"page"},{"location":"examples/RXpi2.html","page":"Rₓ(π/2)","title":"Rₓ(π/2)","text":"In this notebook we show how to design smooth 4 ns pulses to do a R_x(pi2) gate, by including the first 12 levels of a transmon, in a few minutes! (simulations are done in the lab frame)","category":"page"},{"location":"examples/RXpi2.html","page":"Rₓ(π/2)","title":"Rₓ(π/2)","text":"ω₀ = 2π*5.0\nη = -2π*300*1e-3\nωlo = ω₀","category":"page"},{"location":"examples/RXpi2.html","page":"Rₓ(π/2)","title":"Rₓ(π/2)","text":"31.41592653589793","category":"page"},{"location":"examples/RXpi2.html","page":"Rₓ(π/2)","title":"Rₓ(π/2)","text":"n_levels = 12\nbs = FockBasis(n_levels-1)\na = destroy(bs)\nad = create(bs)\nid = identityoperator(bs, bs)","category":"page"},{"location":"examples/RXpi2.html","page":"Rₓ(π/2)","title":"Rₓ(π/2)","text":"H0 = ω₀*(ad*a + 0.5*id) + (η/12.0)*(a + ad)^4 - η^2 * (a + ad)^6/ω₀/90.0\nH1 = 1.0im*(a - ad)","category":"page"},{"location":"examples/RXpi2.html","page":"Rₓ(π/2)","title":"Rₓ(π/2)","text":"we parametrize the waveforms using a neural network with one input (t) and two outputs (I(t) and Q(t)), we then train the neural network to produce DRAG pulse like waveforms","category":"page"},{"location":"examples/RXpi2.html","page":"Rₓ(π/2)","title":"Rₓ(π/2)","text":"n_neurons = 8\nRandom.seed!(1)\nann = FastChain(FastDense(1, n_neurons, tanh), \n                FastDense(n_neurons, n_neurons, tanh),\n                FastDense(n_neurons, 2))\nt0, t1 = 0.0, 4.0\n\nI_guess(t) = @. -2π*exp(-(t-0.5*t1)^2/(0.2*t1)^2)*2.0*(t-0.5*t1) /(0.2*t1)^2\nQ_guess(t) = @. -2π*exp(-(t-0.5*t1)^2/(0.2*t1)^2)\n\ntsf32 = Float32(t0):0.001f0:Float32(t1)\nIs = Vector{Float32}(I_guess(tsf32))\nQs = Vector{Float32}(Q_guess(tsf32))\n\nts = Vector{Float64}(tsf32)\nfunction loss(p)\n    c = 0.0f0\n    for (i,t) in enumerate(tsf32)\n        x = ann([t], p)\n        c += (x[1] - Is[i])^2\n        c += (x[2] - Qs[i])^2\n    end\n    c\nend\nres = DiffEqFlux.sciml_train(loss, initial_params(ann), Adam(0.1f0), maxiters = 500)\nθ = Vector{Float64}(res.u)","category":"page"},{"location":"examples/RXpi2.html","page":"Rₓ(π/2)","title":"Rₓ(π/2)","text":"time dependant drive after mixing with local oscillator","category":"page"},{"location":"examples/RXpi2.html","page":"Rₓ(π/2)","title":"Rₓ(π/2)","text":"coeffs(params, t) = let b = ann([t], params)\n                        [b[1]*cos(ωlo*t) + b[2]*sin(ωlo*t)]\n                    end","category":"page"},{"location":"examples/RXpi2.html","page":"Rₓ(π/2)","title":"Rₓ(π/2)","text":"coeffs (generic function with 1 method)","category":"page"},{"location":"examples/RXpi2.html","page":"Rₓ(π/2)","title":"Rₓ(π/2)","text":"we specify the objective to optimize, first argument includes the infidelity and the second one takes the constraints on the waveforms, here we simply pin I and Q to be zero at t_0 and t_1","category":"page"},{"location":"examples/RXpi2.html","page":"Rₓ(π/2)","title":"Rₓ(π/2)","text":"bcs(params) = 0.01*sum(ann([t0], params).^2 + ann([t1], params).^2)\n                 \ncost = CostFunction((x,y)-> 1.0-real(x'*y), bcs)","category":"page"},{"location":"examples/RXpi2.html","page":"Rₓ(π/2)","title":"Rₓ(π/2)","text":"CostFunction(var\"#1#2\"(), bcs)","category":"page"},{"location":"examples/RXpi2.html","page":"Rₓ(π/2)","title":"Rₓ(π/2)","text":"Unitary transformation denoting R_x(pi2) gate","category":"page"},{"location":"examples/RXpi2.html","page":"Rₓ(π/2)","title":"Rₓ(π/2)","text":"trans = UnitaryTransform([fockstate(bs, 0), fockstate(bs, 1)], \n                         [[1.0 -1.0im];[-1.0im 1.0]]/√2)","category":"page"},{"location":"examples/RXpi2.html","page":"Rₓ(π/2)","title":"Rₓ(π/2)","text":"Hamiltonian of the problem","category":"page"},{"location":"examples/RXpi2.html","page":"Rₓ(π/2)","title":"Rₓ(π/2)","text":"H = Hamiltonian(H0, [H1], coeffs)","category":"page"},{"location":"examples/RXpi2.html","page":"Rₓ(π/2)","title":"Rₓ(π/2)","text":"QOCProblem definition","category":"page"},{"location":"examples/RXpi2.html","page":"Rₓ(π/2)","title":"Rₓ(π/2)","text":"prob = QOCProblem(H, trans, (t0, t1), cost)","category":"page"},{"location":"examples/RXpi2.html","page":"Rₓ(π/2)","title":"Rₓ(π/2)","text":"we use the DRAG like pulses as an initial guess and solve the problem","category":"page"},{"location":"examples/RXpi2.html","page":"Rₓ(π/2)","title":"Rₓ(π/2)","text":"@time sol = solve(prob, θ, Adam(0.02); maxiter=100)","category":"page"},{"location":"examples/RXpi2.html","page":"Rₓ(π/2)","title":"Rₓ(π/2)","text":"\u001b[32mProgress: 100%|█████████████████████████████████████████| Time: 0:02:34\u001b[39m\r\n\u001b[34m  distance:     0.00487591354733552\u001b[39m\r\n\u001b[34m  constraints:  7.803988353750598e-5\u001b[39m\n\n\n171.865075 seconds (664.66 M allocations: 62.231 GiB, 23.89% gc time, 20.43% compilation time)","category":"page"},{"location":"examples/RXpi2.html","page":"Rₓ(π/2)","title":"Rₓ(π/2)","text":"plot(sol.distance_trace, label=\"infidelity\")\nplot!(sol.constraints_trace, label=\"constraints\")","category":"page"},{"location":"examples/RXpi2.html","page":"Rₓ(π/2)","title":"Rₓ(π/2)","text":"(Image: svg)","category":"page"},{"location":"examples/RXpi2.html","page":"Rₓ(π/2)","title":"Rₓ(π/2)","text":"I_wf(t) = ann([t], sol.params)[1]/2π\nQ_wf(t) = ann([t], sol.params)[2]/2π","category":"page"},{"location":"examples/RXpi2.html","page":"Rₓ(π/2)","title":"Rₓ(π/2)","text":"Q_wf (generic function with 1 method)","category":"page"},{"location":"examples/RXpi2.html","page":"Rₓ(π/2)","title":"Rₓ(π/2)","text":"plot(ts, I_wf.(ts), label=\"I\")\nplot!(ts, Q_wf.(ts), label=\"Q\")\nxlabel!(\"Time (ns)\")\nylabel!(\"Frequency (GHz)\")","category":"page"},{"location":"examples/RXpi2.html","page":"Rₓ(π/2)","title":"Rₓ(π/2)","text":"(Image: svg)","category":"page"},{"location":"examples/RXpi2.html","page":"Rₓ(π/2)","title":"Rₓ(π/2)","text":"tout, psit = schroedinger_dynamic(ts, fockstate(bs, 0), H, sol.params)","category":"page"},{"location":"examples/RXpi2.html","page":"Rₓ(π/2)","title":"Rₓ(π/2)","text":"f = plot()\nfor i in 0:11\n    plot!(f, ts, real(expect(dm(fockstate(bs, i)), psit)),\n          label=\"|\"*string(i)*\"⟩\", legend=:left)\nend\nxlabel!(f, \"Time (ns)\")\nylabel!(f, \"Population (⟨i|ψ⟩²)\")\nf","category":"page"},{"location":"examples/RXpi2.html","page":"Rₓ(π/2)","title":"Rₓ(π/2)","text":"(Image: svg)","category":"page"},{"location":"examples/TwoLevelSystem.html#Two-level-system","page":"Two-level system","title":"Two-level system","text":"","category":"section"},{"location":"examples/TwoLevelSystem.html","page":"Two-level system","title":"Two-level system","text":"We consider the following simple two-level system Hamiltonian","category":"page"},{"location":"examples/TwoLevelSystem.html","page":"Two-level system","title":"Two-level system","text":"H(t) = -fracomega_02sigma_z + Omega(t)sigma_x","category":"page"},{"location":"examples/TwoLevelSystem.html","page":"Two-level system","title":"Two-level system","text":"using Sisyphus\nusing QuantumOptics\nusing Flux, DiffEqFlux\nusing Plots\nusing Random\nusing ProgressMeter\n\nProgressMeter.ijulia_behavior(:clear)","category":"page"},{"location":"examples/TwoLevelSystem.html","page":"Two-level system","title":"Two-level system","text":"We use a dense neural network with three hidden layers to represent our parameterized pulse Omega(t) and constrain it to be an even function of time.","category":"page"},{"location":"examples/TwoLevelSystem.html","page":"Two-level system","title":"Two-level system","text":"n_neurons = 15\n\nRandom.seed!(0)\nann = FastChain(FastDense(1, n_neurons, tanh),\n                FastDense(n_neurons, n_neurons, tanh),\n                FastDense(n_neurons, n_neurons, tanh),\n                FastDense(n_neurons, 1))\nθ = Vector{Float64}(initial_params(ann))\nprintln(\"Number of parameters: \", length(θ))\n\nΩ(params, t) = (ann([t - t0], params)[1] + ann([t1 - t], params)[1]) / 2.0","category":"page"},{"location":"examples/TwoLevelSystem.html","page":"Two-level system","title":"Two-level system","text":"Number of parameters: 526","category":"page"},{"location":"examples/TwoLevelSystem.html","page":"Two-level system","title":"Two-level system","text":"We also define a boundary condition that constraints the pulse to be zero at initial and final times.","category":"page"},{"location":"examples/TwoLevelSystem.html","page":"Two-level system","title":"Two-level system","text":"(t0, t1) = (0.0, 1.0)\ncost = CostFunction((x,y) -> 1.0 - abs2(x'*y), p -> Ω(p, t0)^2 + Ω(p, t1)^2)","category":"page"},{"location":"examples/TwoLevelSystem.html","page":"Two-level system","title":"Two-level system","text":"Our target unitary performs a transfer of population between the two levels downarrowrangle and uparrowrangle. In this case, it is sufficient to define a transformation on only one of the states since the transformation for the other state is implied by the unitarity.","category":"page"},{"location":"examples/TwoLevelSystem.html","page":"Two-level system","title":"Two-level system","text":"bs = SpinBasis(1//2)\ntrans = StateTransform(spindown(bs) => spinup(bs))","category":"page"},{"location":"examples/TwoLevelSystem.html","page":"Two-level system","title":"Two-level system","text":"H = Hamiltonian(-0.5*sigmaz(bs), [sigmax(bs)], Ω)\nprob = QOCProblem(H, trans, (t0, t1), cost)\n\n@time sol = solve(prob, θ, Adam(0.05); maxiter=500)","category":"page"},{"location":"examples/TwoLevelSystem.html","page":"Two-level system","title":"Two-level system","text":"\u001b[32mProgress: 100%|█████████████████████████████████████████| Time: 0:03:43\u001b[39m\r\n\u001b[34m  distance:     5.450727475431183e-5\u001b[39m\r\n\u001b[34m  constraints:  4.548351191997502e-7\u001b[39m\n\n\n255.495667 seconds (406.28 M allocations: 38.566 GiB, 66.92% gc time, 23.98% compilation time)","category":"page"},{"location":"examples/TwoLevelSystem.html","page":"Two-level system","title":"Two-level system","text":"ts = t0:t1/100:t1\n\nplot(ts, [Ω(sol.params, t) for t in ts])\nplot!(xlabel=\"t (a.u.)\", ylabel=\"Ω / ω₀\", legend=false)","category":"page"},{"location":"examples/TwoLevelSystem.html","page":"Two-level system","title":"Two-level system","text":"(Image: svg)","category":"page"},{"location":"examples/TwoLevelSystem.html","page":"Two-level system","title":"Two-level system","text":"We also run schroedinger_dynamic from QuantumOptics.jl to present how the system evolved over time and how the level population changed.","category":"page"},{"location":"examples/TwoLevelSystem.html","page":"Two-level system","title":"Two-level system","text":"tout, psit = schroedinger_dynamic(ts, spindown(bs), H, sol.params)\n\nplot(tout, real(expect(dm(spindown(bs)), psit)), label=\"|↓⟩\")\nplot!(tout, real(expect(dm(spinup(bs)), psit)), label=\"|↑⟩\")\nplot!(xlabel=\"t (a.u.)\", ylabel=\"Level population |⟨i|ψ⟩|²\", legend=:right)","category":"page"},{"location":"examples/TwoLevelSystem.html","page":"Two-level system","title":"Two-level system","text":"(Image: svg)","category":"page"},{"location":"examples/DRAG.html#DRAG","page":"DRAG","title":"DRAG","text":"","category":"section"},{"location":"examples/DRAG.html","page":"DRAG","title":"DRAG","text":"In realization of quantum computing, two lowest energy levels are often singled out to represent a qubit. However, simple qubit control of these two levels fails at short time scales due to coupling and leakage to higher energy levels. Derivative removal by adiabatic gate (DRAG) is a simple analytic pulse expression devised to combat this leakage. ","category":"page"},{"location":"examples/DRAG.html","page":"DRAG","title":"DRAG","text":"Let's consider the following Hamiltonian of a three level system that approximates a transmon qubit in a frame rotating at the qubit frequency","category":"page"},{"location":"examples/DRAG.html","page":"DRAG","title":"DRAG","text":"H(t) = Delta2ranglelangle2 + fracOmega_x(t)2sum_j = 1^2sigma^x_j j-1 + fracOmega_y(t)2sum_j = 1^2sigma^y_j j-1","category":"page"},{"location":"examples/DRAG.html","page":"DRAG","title":"DRAG","text":"where operators sigma^x_j j-1 = sqrtj(jranglelangle j-1 + j-1ranglelangle j) and sigma^y_j j-1 = isqrtj(jranglelangle j-1 - j-1ranglelangle j) couple adjacent energy levels.","category":"page"},{"location":"examples/DRAG.html","page":"DRAG","title":"DRAG","text":"using Sisyphus\nusing QuantumOptics\nusing Flux\nusing Plots\nusing Random\nusing ProgressMeter\n\nProgressMeter.ijulia_behavior(:clear)","category":"page"},{"location":"examples/DRAG.html","page":"DRAG","title":"DRAG","text":"We define our Hamiltonian using QuantumOptics.jl library.","category":"page"},{"location":"examples/DRAG.html","page":"DRAG","title":"DRAG","text":"Δ = -0.3 * 2π # in GHz\n\nbs = NLevelBasis(3)\nH0 = Δ * transition(bs, 3, 3)\nHx = transition(bs, 2, 1) + transition(bs, 1, 2) + √2 * (transition(bs, 3, 2) + transition(bs, 2, 3))\nHy = 1im * (transition(bs, 2, 1) - transition(bs, 1, 2) + √2 * (transition(bs, 3, 2) - transition(bs, 2, 3)))","category":"page"},{"location":"examples/DRAG.html","page":"DRAG","title":"DRAG","text":"To induce transitions 0rangle leftrightarrow 1rangle, one can use the following Gaussian shaped parameterized DRAG pulses","category":"page"},{"location":"examples/DRAG.html","page":"DRAG","title":"DRAG","text":"Omega_x(t) = A left( expleft -fracleft(t-T2right)^22sigma^2 right - expleft-fracT^28sigma^2right right)","category":"page"},{"location":"examples/DRAG.html","page":"DRAG","title":"DRAG","text":"Omega_y(t) = fracbetaDeltafracmathrmdOmega_x(t)mathrmdt","category":"page"},{"location":"examples/DRAG.html","page":"DRAG","title":"DRAG","text":"We set the spread of Gaussian to be a quarter of the total pulse duration sigma = T  4, while we keep the amplitudes A and beta as free parameters to be optimized.","category":"page"},{"location":"examples/DRAG.html","page":"DRAG","title":"DRAG","text":"T = 4.0 # in ns\nσ = T / 4\n\nΩx(A, t) = A * (exp(-(t - T / 2)^2 / (2σ^2)) - exp(-T^2 / (8σ^2)))\nΩy(A, β, t) = -2 * (β / Δ) * A * (t - T / 2) * exp(-(t - T / 2)^2 / (2σ^2))\n\ncoeffs(p, t) = [Ωx(p[1], t) / 2, Ωy(p[1], p[2], t) / 2]\n\n# initial parameters\nθ = [0.0, 0.0]","category":"page"},{"location":"examples/DRAG.html","page":"DRAG","title":"DRAG","text":"Next, we define a cost function to be the infidelity between current and target states.","category":"page"},{"location":"examples/DRAG.html","page":"DRAG","title":"DRAG","text":"cost = CostFunction((x, y) -> 1.0 - abs2(x'*y))","category":"page"},{"location":"examples/DRAG.html","page":"DRAG","title":"DRAG","text":"We define define the desired unitary transformation as R_x(pi2) rotation in the subspace spanned by the states 0rangle and 1rangle.","category":"page"},{"location":"examples/DRAG.html","page":"DRAG","title":"DRAG","text":"trans = UnitaryTransform([nlevelstate(bs, 1), nlevelstate(bs, 2)], \n                         [[1.0 -1.0im];[-1.0im 1.0]]/√2)","category":"page"},{"location":"examples/DRAG.html","page":"DRAG","title":"DRAG","text":"Finally, we define and solve the corresponding quantum optimal control problem.","category":"page"},{"location":"examples/DRAG.html","page":"DRAG","title":"DRAG","text":"tspan = (0.0, T)\nH = Hamiltonian(H0, [Hx, Hy], coeffs)\nprob = QOCProblem(H, trans, tspan, cost)\n\n@time sol = solve(prob, θ, Adam(0.01); maxiter=300)","category":"page"},{"location":"examples/DRAG.html","page":"DRAG","title":"DRAG","text":"\u001b[32mProgress: 100%|█████████████████████████████████████████| Time: 0:01:40\u001b[39m\r\n\u001b[34m  distance:     0.004422744991859184\u001b[39m\r\n\u001b[34m  constraints:  0.0\u001b[39m\n\n\n119.669943 seconds (98.44 M allocations: 5.565 GiB, 71.11% gc time, 28.79% compilation time)","category":"page"},{"location":"examples/DRAG.html","page":"DRAG","title":"DRAG","text":"plot(sol.distance_trace, yscale=:log10, xlabel=\"iterations\", ylabel=\"infidelity\", legend=false)","category":"page"},{"location":"examples/DRAG.html","page":"DRAG","title":"DRAG","text":"(Image: svg)","category":"page"},{"location":"examples/DRAG.html","page":"DRAG","title":"DRAG","text":"ts = collect(0:T/100.0:T)\nplot(ts, Ωx.(sol.params[1], ts), label=\"Ωx\")\nplot!(ts, Ωy.(sol.params[1], sol.params[2], ts), label=\"Ωy\")\nplot!(xlabel=\"time (ns)\", ylabel=\"frequency (GHz)\")","category":"page"},{"location":"examples/DRAG.html","page":"DRAG","title":"DRAG","text":"(Image: svg)","category":"page"},{"location":"examples/CZ.html#CZ-gate-in-Rydberg-atoms","page":"CZ gate in Rydberg atoms","title":"CZ gate in Rydberg atoms","text":"","category":"section"},{"location":"examples/CZ.html","page":"CZ gate in Rydberg atoms","title":"CZ gate in Rydberg atoms","text":"H = fracOmega(t)2lefte^iphi(t) (sigma_+^1 + sigma_+^2) +  e^-iphi(t) (sigma_-^1+sigma_-^2)right - Delta(t) (n_1 + n_2) + V n_1n_2","category":"page"},{"location":"examples/CZ.html","page":"CZ gate in Rydberg atoms","title":"CZ gate in Rydberg atoms","text":"see Levine et al.","category":"page"},{"location":"examples/CZ.html","page":"CZ gate in Rydberg atoms","title":"CZ gate in Rydberg atoms","text":"using Sisyphus\nusing QuantumOptics\nusing Flux, DiffEqFlux\nusing Plots\nusing Random\nusing ProgressMeter\n\nProgressMeter.ijulia_behavior(:clear)","category":"page"},{"location":"examples/CZ.html","page":"CZ gate in Rydberg atoms","title":"CZ gate in Rydberg atoms","text":"V = 2π*10.0; # MHz","category":"page"},{"location":"examples/CZ.html","page":"CZ gate in Rydberg atoms","title":"CZ gate in Rydberg atoms","text":"bs = NLevelBasis(3)\nbsys = bs⊗bs\n\nid = identityoperator(bs)\n\nsp1 = transition(bs, 3, 2)⊗id\nsm1 = transition(bs, 2, 3)⊗id\n\nsp2 = id⊗transition(bs, 3, 2)\nsm2 = id⊗transition(bs, 2, 3)\n\nn1 = transition(bs, 3, 3)⊗id\nn2 = id⊗transition(bs, 3, 3)","category":"page"},{"location":"examples/CZ.html","page":"CZ gate in Rydberg atoms","title":"CZ gate in Rydberg atoms","text":"H0 = V*(n1*n2)\nH1 = (n1 + n2)\nH2 = (sp1 + sp2 + sm1 + sm2)\nH3 = 1.0im*(sp1 + sp2 - sm1 - sm2)","category":"page"},{"location":"examples/CZ.html","page":"CZ gate in Rydberg atoms","title":"CZ gate in Rydberg atoms","text":"states= [nlevelstate(bs, 1)⊗nlevelstate(bs, 1),\n         nlevelstate(bs, 1)⊗nlevelstate(bs, 2),\n         nlevelstate(bs, 2)⊗nlevelstate(bs, 1),\n         nlevelstate(bs, 2)⊗nlevelstate(bs, 2)]\n\ntrans = UnitaryTransform(states, [[1.0 0 0 0 ];[0 1.0 0 0 ];[0 0 1.0 0 ]; [0 0 0 -1.0]])","category":"page"},{"location":"examples/CZ.html","page":"CZ gate in Rydberg atoms","title":"CZ gate in Rydberg atoms","text":"n_neurons = 4\nann = FastChain(FastDense(1, n_neurons, tanh), \n                FastDense(n_neurons, n_neurons, tanh), \n                FastDense(n_neurons, n_neurons, tanh), \n                FastDense(n_neurons, 3))\nθ = initial_params(ann)     \nn_params = length(θ);\nRandom.seed!(3)\nθ = 2.0*rand(n_params).-1.0","category":"page"},{"location":"examples/CZ.html","page":"CZ gate in Rydberg atoms","title":"CZ gate in Rydberg atoms","text":"t0, t1 = 0.0, 1.0\nsigmoid(x)= @. 2π*7 / (1 + exp(-x))\ncoeffs(p, t) = let vals = ann([t], p)\n                [-vals[1], sigmoid(vals[2])*cos(vals[3]), sigmoid(vals[2])*sin(vals[3])]\n               end    \ncost = CostFunction((x, y) -> 1.0-real(x'*y),\n                     p->2e-2*(sigmoid(ann([t0], p)[2])^2 + sigmoid(ann([t1], p)[2])^2))\n\nH = Hamiltonian(H0, [H1, H2, H3], coeffs)\nprob = QOCProblem(H, trans, (t0, t1), cost)","category":"page"},{"location":"examples/CZ.html","page":"CZ gate in Rydberg atoms","title":"CZ gate in Rydberg atoms","text":"sol = solve(prob, θ, Adam(0.008); maxiter=2000, abstol=1e-6, reltol=1e-6)","category":"page"},{"location":"examples/CZ.html","page":"CZ gate in Rydberg atoms","title":"CZ gate in Rydberg atoms","text":"\u001b[32mProgress: 100%|█████████████████████████████████████████| Time: 0:15:37\u001b[39m\r\n\u001b[34m  distance:     0.0018210702524238953\u001b[39m\r\n\u001b[34m  constraints:  0.015069570351528385\u001b[39m","category":"page"},{"location":"examples/CZ.html","page":"CZ gate in Rydberg atoms","title":"CZ gate in Rydberg atoms","text":"cost.constraints = p->(sigmoid(ann([t0], p)[2])^2 + sigmoid(ann([t1], p)[2])^2)\nsol1 = solve(prob, sol.params, Adam(0.008); maxiter=500, abstol=1e-6, reltol=1e-6)","category":"page"},{"location":"examples/CZ.html","page":"CZ gate in Rydberg atoms","title":"CZ gate in Rydberg atoms","text":"\u001b[32mProgress: 100%|█████████████████████████████████████████| Time: 0:03:45\u001b[39m\r\n\u001b[34m  distance:     0.006063003962643532\u001b[39m\r\n\u001b[34m  constraints:  0.012359362552093491\u001b[39m","category":"page"},{"location":"examples/CZ.html","page":"CZ gate in Rydberg atoms","title":"CZ gate in Rydberg atoms","text":"Ω(t) = sigmoid(ann([t], sol1.params)[2])/2π\nΔ(t) = -ann([t], sol1.params)[1]/2π\nϕ(t) = ann([t], sol1.params)[3]","category":"page"},{"location":"examples/CZ.html","page":"CZ gate in Rydberg atoms","title":"CZ gate in Rydberg atoms","text":"green = theme_palette(:auto).colors.colors[3]\n\nts = collect(t0:t1/100:t1)\nplot(ts, Ω.(ts), label=\"Ω/2π\")\nplot!(ts, Δ.(ts), label=\"Δ/2π\")\nylabel!(\"Waveform (MHz)\")\nplot!(Plots.twinx(), ts, ϕ.(ts), ylabel=\"ϕ (Radians)\", color=green,\n      yguidefont = font(green), legend=false)\nxlabel!(\"Time (µs)\", right_margin = 15Plots.mm)","category":"page"},{"location":"examples/CZ.html","page":"CZ gate in Rydberg atoms","title":"CZ gate in Rydberg atoms","text":"(Image: svg)","category":"page"},{"location":"examples/CZ.html","page":"CZ gate in Rydberg atoms","title":"CZ gate in Rydberg atoms","text":"tout, psit22 = schroedinger_dynamic(ts, nlevelstate(bs, 2)⊗nlevelstate(bs, 2),\n                                    H, sol1.params)\ntout, psit21 = schroedinger_dynamic(ts, nlevelstate(bs, 2)⊗nlevelstate(bs, 1),\n                                    H, sol1.params)\ntout, psit12 = schroedinger_dynamic(ts, nlevelstate(bs, 1)⊗nlevelstate(bs, 2),\n                                    H, sol1.params)\ntout, psit11 = schroedinger_dynamic(ts, nlevelstate(bs, 1)⊗nlevelstate(bs, 1),\n                                    H, sol1.params)","category":"page"},{"location":"examples/CZ.html","page":"CZ gate in Rydberg atoms","title":"CZ gate in Rydberg atoms","text":"plot(tout, [real((nlevelstate(bs, 2)⊗nlevelstate(bs, 2))'*elm) for elm in psit22], label=\"|22⟩\")\nplot!(tout, [real((nlevelstate(bs, 2)⊗nlevelstate(bs, 1))'*elm) for elm in psit21], label=\"|21⟩\")\nplot!(tout, [real((nlevelstate(bs, 1)⊗nlevelstate(bs, 2))'*elm) for elm in psit12], label=\"|12⟩\")\nplot!(tout, [real((nlevelstate(bs, 1)⊗nlevelstate(bs, 1))'*elm) for elm in psit11], label=\"|11⟩\", legend=:bottomright)        \nxlabel!(\"Time (µs)\")\nylabel!(\"Overlap (⟨ij|ψ⟩)\")","category":"page"},{"location":"examples/CZ.html","page":"CZ gate in Rydberg atoms","title":"CZ gate in Rydberg atoms","text":"(Image: svg)","category":"page"},{"location":"noisy.html#Open-quantum-systems","page":"Open quantum systems","title":"Open quantum systems","text":"","category":"section"},{"location":"noisy.html","page":"Open quantum systems","title":"Open quantum systems","text":"Quantum systems interacting with the environment can be modelled with the Master equation,","category":"page"},{"location":"noisy.html","page":"Open quantum systems","title":"Open quantum systems","text":"dotrho = -iH rho  + sum_k gamma_k big( J_k rho J_k^dagger - frac12 J_k^dagger J_k rho - frac12 rho J_k^dagger J_k big)","category":"page"},{"location":"noisy.html","page":"Open quantum systems","title":"Open quantum systems","text":"where J_k are the jump operators and gamma_k the respective jump rates. Using the vectorization identity (textvec(A B C) = (C^T otimes A)textvec(B)), we can cast a quantum optimal control problem in the presence of Lindbladian noise into a QOCProblem in the absence of noise, but with an effective Hamiltonian,","category":"page"},{"location":"noisy.html","page":"Open quantum systems","title":"Open quantum systems","text":"H^e = I otimes H - H^T otimes I + isum_k gamma_kJ_k^*otimes J_k - frac12 I otimes J_k^daggerJ_k - frac12J_k^TJ_k^*otimes I","category":"page"},{"location":"noisy.html","page":"Open quantum systems","title":"Open quantum systems","text":"acting on the vectorized form of the density matrix. This trick allows us to use the same solver to solve optimal control problems in the presence of noise.","category":"page"},{"location":"noisy.html","page":"Open quantum systems","title":"Open quantum systems","text":"For a general time-dependent Hamiltonian H(t) = H_0 + H_c(t), the effective time-dependent Hamiltonian is,","category":"page"},{"location":"noisy.html","page":"Open quantum systems","title":"Open quantum systems","text":"H^e(t) = H^e_0 + I otimes H_c(t) - H_c(t)^T otimes I","category":"page"},{"location":"noisy.html","page":"Open quantum systems","title":"Open quantum systems","text":"where the constant part of the effective Hamiltonian is,","category":"page"},{"location":"noisy.html","page":"Open quantum systems","title":"Open quantum systems","text":"H^e_0 = I otimes H_0 - H_0^T otimes I + isum_k gamma_kJ_k^*otimes J_k - frac12 I otimes J_k^daggerJ_k - frac12J_k^TJ_k^*otimes I","category":"page"},{"location":"examples/GHZState.html#GHZ-state-in-Rydberg-atoms","page":"GHZ state","title":"GHZ state in Rydberg atoms","text":"","category":"section"},{"location":"examples/GHZState.html","page":"GHZ state","title":"GHZ state","text":"In this tutorial, we describe the preparation of the N-particle GHZ state","category":"page"},{"location":"examples/GHZState.html","page":"GHZ state","title":"GHZ state","text":"textGHZ_Nrangle = frac1sqrt2left(0101dotsrangle + 1010dotsrangleright)","category":"page"},{"location":"examples/GHZState.html","page":"GHZ state","title":"GHZ state","text":"in a linear chain of Rydberg atoms, as described in Omran et al. 2019.","category":"page"},{"location":"examples/GHZState.html","page":"GHZ state","title":"GHZ state","text":"1D array of Rydberg atoms driven by global pulses can be desribed with the following Hamiltonian","category":"page"},{"location":"examples/GHZState.html","page":"GHZ state","title":"GHZ state","text":"H(t) =  fracOmega(t)2sum_i = 1^Nsigma_x^(i) - sum_i = 1^NDelta_i(t)n_i + sum_i  jfracVi-j^6n_in_j","category":"page"},{"location":"examples/GHZState.html","page":"GHZ state","title":"GHZ state","text":"where n_i = 1ranglelangle1_i are the excited state occupation operators. Delta_i(t) = Delta(t) + delta_i is the local effective detuning set by the Rydberg laser and the local light shift. We set delta_i = delta_e to be non-zero only on atoms 1 and N.","category":"page"},{"location":"examples/GHZState.html","page":"GHZ state","title":"GHZ state","text":"using Sisyphus\nusing QuantumOptics\nusing Flux, DiffEqFlux\nusing Plots\nusing ProgressMeter\nusing Random\n\nProgressMeter.ijulia_behavior(:clear)","category":"page"},{"location":"examples/GHZState.html","page":"GHZ state","title":"GHZ state","text":"T = 1.1 # in μs\nV = 2π * 24.0 # in MHz\nδe = -2π * 4.5 # in MHz\nn_atoms = 4\n\nbs = SpinBasis(1//2)\nsx = sigmax(bs)\nni = 0.5*(identityoperator(bs) + sigmaz(bs))\n\nbsys = tensor([bs for i in 1:n_atoms]...)\nH0 = V*sum([embed(bsys, [i, j], [ni, ni])/abs(i-j)^6  for i in 1:n_atoms for j in i+1:n_atoms])\nH0 -= δe*sum([embed(bsys, [i], [ni]) for i in [1, n_atoms]])\nH1 = 0.5*sum([embed(bsys, [i], [sx]) for i in 1:n_atoms])\nH2 = -sum([embed(bsys, [i], [ni]) for i in 1:n_atoms])","category":"page"},{"location":"examples/GHZState.html","page":"GHZ state","title":"GHZ state","text":"We provide initial guesses for our pulses.","category":"page"},{"location":"examples/GHZState.html","page":"GHZ state","title":"GHZ state","text":"Ω₀(t) = 2π * min(5.0, 25.0 * t / T, 25.0 * (T - t) / T)\nΔ₀(t) = 2π * (30.0 * t / T - 15.0)\n\nts = collect(0.0:0.001:T)\n\nblue = theme_palette(:auto).colors.colors[1]\nred = theme_palette(:auto).colors.colors[2]\nplot(ts, Δ₀.(ts)/2π, ylabel=\"Δ/2π (MHz)\", color=blue, yguidefont = font(blue), legend=false)\nplot!(Plots.twinx(), ts, Ω₀.(ts)/2π, ylabel=\"Ω/2π (MHz)\", color=red, yguidefont = font(red), legend=false)\nplot!(xlabel=\"time (μs)\", right_margin = 15Plots.mm)","category":"page"},{"location":"examples/GHZState.html","page":"GHZ state","title":"GHZ state","text":"(Image: svg)","category":"page"},{"location":"examples/GHZState.html","page":"GHZ state","title":"GHZ state","text":"Ω(p, t) = piecewise_const_interp(p[begin:length(p)÷2], t; t0=0.0, t1=T)\nΔ(p, t) = piecewise_const_interp(p[length(p)÷2+1:end], t; t0=0.0, t1=T)\n\nn_params = 30\nts = collect(0.0:T/n_params:T)\nθ = vcat([Ω₀((ts[i+1] + ts[i])/2) for i=1:n_params], [Δ₀((ts[i+1] + ts[i])/2) for i=1:n_params])","category":"page"},{"location":"examples/GHZState.html","page":"GHZ state","title":"GHZ state","text":"ts = collect(0.0:0.001:T)\n\nblue = theme_palette(:auto).colors.colors[1]\nred = theme_palette(:auto).colors.colors[2]\nplot(ts, [Δ(θ, t)/2π for t in ts], ylabel=\"Δ/2π (MHz)\", color=blue, yguidefont = font(blue), legend=false)\nplot!(Plots.twinx(), ts, [Ω(θ, t)/2π for t in ts], ylabel=\"Ω/2π (MHz)\", color=red, yguidefont = font(red), legend=false)\nplot!(xlabel=\"time (μs)\", right_margin = 15Plots.mm)","category":"page"},{"location":"examples/GHZState.html","page":"GHZ state","title":"GHZ state","text":"(Image: svg)","category":"page"},{"location":"examples/GHZState.html","page":"GHZ state","title":"GHZ state","text":"function GHZ_state(n_atoms)\n    state = tensor([isodd(i) ? spindown(bs) : spinup(bs) for i=1:n_atoms]...) +\n            tensor([isodd(i) ? spinup(bs) : spindown(bs) for i=1:n_atoms]...)\n    state/sqrt(2.0)\nend \n\nground_state(n_atoms) = tensor([spindown(bs) for i in 1:n_atoms]...)\n\ncost = CostFunction((x, y) -> 1.0 - abs2(x'*y))\ntrans = StateTransform(ground_state(n_atoms) => GHZ_state(n_atoms))\nH = Hamiltonian(H0, [H1, H2], (p, t) -> [Ω(p, t), Δ(p, t)])","category":"page"},{"location":"examples/GHZState.html","page":"GHZ state","title":"GHZ state","text":"tout, psit = schroedinger_dynamic(ts, ground_state(n_atoms), H, θ)","category":"page"},{"location":"examples/GHZState.html","page":"GHZ state","title":"GHZ state","text":"plot(ts, real(expect(dm(GHZ_state(n_atoms)), psit)))\nplot!(xlabel=\"Time (μs)\", ylabel=\"Overlap (|⟨ψ|GHZ⟩|²)\", legend=false)","category":"page"},{"location":"examples/GHZState.html","page":"GHZ state","title":"GHZ state","text":"(Image: svg)","category":"page"},{"location":"examples/GHZState.html","page":"GHZ state","title":"GHZ state","text":"println(\"Fidelity: \", real(expect(dm(GHZ_state(n_atoms)), psit[end])))","category":"page"},{"location":"examples/GHZState.html","page":"GHZ state","title":"GHZ state","text":"Fidelity: 0.9856598145164646","category":"page"},{"location":"examples/GHZState.html","page":"GHZ state","title":"GHZ state","text":"prob = QOCProblem(H, trans, (0.0, T), cost)\nsol = solve(prob, θ, Adam(0.2); abstol=1e-6, reltol=1e-6)","category":"page"},{"location":"examples/GHZState.html","page":"GHZ state","title":"GHZ state","text":"\u001b[32mProgress: 100%|█████████████████████████████████████████| Time: 0:05:16\u001b[39m\r\n\u001b[34m  distance:     4.671056424032649e-5\u001b[39m\r\n\u001b[34m  constraints:  0.0\u001b[39m","category":"page"},{"location":"examples/GHZState.html","page":"GHZ state","title":"GHZ state","text":"plot(sol.distance_trace)","category":"page"},{"location":"examples/GHZState.html","page":"GHZ state","title":"GHZ state","text":"(Image: svg)","category":"page"},{"location":"examples/GHZState.html","page":"GHZ state","title":"GHZ state","text":"ts = collect(0.0:0.001:T)\n\nblue = theme_palette(:auto).colors.colors[1]\nred = theme_palette(:auto).colors.colors[2]\nplot(ts, [Δ(sol.params, t)/2π for t in ts], ylabel=\"Δ/2π (MHz)\", color=blue, yguidefont = font(blue), legend=false)\nplot!(Plots.twinx(), ts, [Ω(sol.params, t)/2π for t in ts], ylabel=\"Ω/2π (MHz)\", color=red, yguidefont = font(red), legend=false)\nplot!(xlabel=\"time (μs)\", right_margin = 15Plots.mm)","category":"page"},{"location":"examples/GHZState.html","page":"GHZ state","title":"GHZ state","text":"(Image: svg)","category":"page"},{"location":"examples/GHZState.html","page":"GHZ state","title":"GHZ state","text":"tout, psit = schroedinger_dynamic(ts, ground_state(n_atoms), H, sol.params)","category":"page"},{"location":"examples/GHZState.html","page":"GHZ state","title":"GHZ state","text":"plot(ts, real(expect(dm(GHZ_state(n_atoms)), psit)))\nplot!(xlabel=\"Time (μs)\", ylabel=\"Overlap (|⟨ψ|GHZ⟩|²)\", legend=false)","category":"page"},{"location":"examples/GHZState.html","page":"GHZ state","title":"GHZ state","text":"(Image: svg)","category":"page"},{"location":"examples/GHZState.html","page":"GHZ state","title":"GHZ state","text":"println(\"Fidelity: \", real(expect(dm(GHZ_state(n_atoms)), psit[end])))","category":"page"},{"location":"examples/GHZState.html","page":"GHZ state","title":"GHZ state","text":"Fidelity: 0.9999463779819884","category":"page"},{"location":"examples/SQRTiSWAP.html#\\sqrt{i\\text{SWAP}}-gate-in-superconducting-qubits","page":"√iSWAP","title":"sqrtitextSWAP gate in superconducting qubits","text":"","category":"section"},{"location":"examples/SQRTiSWAP.html","page":"√iSWAP","title":"√iSWAP","text":"In this notebook, we design optimal pulses to realize a high fidelity 16ns sqrtitextSWAP gate, we minimize the leakage out of computational space. We model a system of two flux tunable transmons with the following Hamiltonian,","category":"page"},{"location":"examples/SQRTiSWAP.html","page":"√iSWAP","title":"√iSWAP","text":"H = leftomega_1 + f_1(t)right a_1^dagger a_1 + fraceta_112 lefta_1^dagger + a_1right^4 + leftomega_2 + f_2(t)right a_2^dagger a_2 + fraceta_212 lefta_2^dagger + a_2right^4 + g(t) (a_1 - a_1^dagger) (a_2 - a_2^dagger)  ","category":"page"},{"location":"examples/SQRTiSWAP.html","page":"√iSWAP","title":"√iSWAP","text":"using Sisyphus\nusing QuantumOptics\nusing LinearAlgebra\nusing Flux, DiffEqFlux\nusing Plots\nusing OrdinaryDiffEq: DP5, Tsit5, Vern7, Vern9, BS3\nusing Random\nusing ProgressMeter\nProgressMeter.ijulia_behavior(:clear)","category":"page"},{"location":"examples/SQRTiSWAP.html","page":"√iSWAP","title":"√iSWAP","text":"ω₁ = 2π*5.0\nη₁ = -2π*300.0*1e-3\nω₁ += η₁\n\nω₂ = 2π*5.0\n\nη₂ = -2π*300.0*1e-3\nω₂ += η₂\n\nωlo1 = ω₂\nωlo2 = ω₁","category":"page"},{"location":"examples/SQRTiSWAP.html","page":"√iSWAP","title":"√iSWAP","text":"here we consider the first 6 levels of each transmon","category":"page"},{"location":"examples/SQRTiSWAP.html","page":"√iSWAP","title":"√iSWAP","text":"n_levels = 6\nbs = FockBasis(n_levels-1)\nid = identityoperator(bs)\n\na1 = destroy(bs)⊗id\na1d = create(bs)⊗id\na2 = id⊗destroy(bs)\na2d = id⊗create(bs)\nid12 = id⊗id","category":"page"},{"location":"examples/SQRTiSWAP.html","page":"√iSWAP","title":"√iSWAP","text":"H0 = (η₁/12.0)*(a1 + a1d)^4 + (η₂/12.0)*(a2 + a2d)^4 ## anharmonic part\nH1 = (a2 - a2d)*(a1 - a1d) ## capacitive coupling\nH2 = a1d*a1 + 0.5*id12\nH3 = a2d*a2 + 0.5*id12\nt0, t1 = 0.0, 16.0","category":"page"},{"location":"examples/SQRTiSWAP.html","page":"√iSWAP","title":"√iSWAP","text":"Random.seed!(3)\nn_neurons = 8\nann = FastChain(FastDense(1, n_neurons, tanh), \n                FastDense(n_neurons, n_neurons, tanh), \n                FastDense(n_neurons, n_neurons, tanh), \n                FastDense(n_neurons, 3))\nθ = Vector{Float64}(initial_params(ann))     \nn_params = length(θ)","category":"page"},{"location":"examples/SQRTiSWAP.html","page":"√iSWAP","title":"√iSWAP","text":"187","category":"page"},{"location":"examples/SQRTiSWAP.html","page":"√iSWAP","title":"√iSWAP","text":"we first pretrain the neural networks to produce gaussian pulses","category":"page"},{"location":"examples/SQRTiSWAP.html","page":"√iSWAP","title":"√iSWAP","text":"g_guess(t) = @. 0.01*2π*exp(-(t-0.5*t1)^2/(0.2*t1)^2)\nf1_guess(t) = @. 0.1*2π*exp(-(t-0.5*t1)^2/(0.2*t1)^2)\nf2_guess(t) = @. 0.1*2π*exp(-(t-0.5*t1)^2/(0.2*t1)^2)\n\ntsf32 = Float32(t0):0.1f0:Float32(t1)\ngs = Vector{Float32}(g_guess(tsf32))\nf1s = Vector{Float32}(f1_guess(tsf32))\nf2s = Vector{Float32}(f2_guess(tsf32))\n\nts = Vector{Float64}(tsf32)\nfunction loss(p)\n    c = 0.0f0\n    for (i,t) in enumerate(tsf32)\n        x = ann([t], p)\n        c += (x[1] - gs[i])^2\n        c += (x[2] - f1s[i])^2\n        c += (x[3] - f2s[i])^2\n    end\n   # println(c)\n    c\nend\n\nres = DiffEqFlux.sciml_train(loss, initial_params(ann), Adam(0.1f0), maxiters = 500)\nθ = Vector{Float64}(res.u)","category":"page"},{"location":"examples/SQRTiSWAP.html","page":"√iSWAP","title":"√iSWAP","text":"coeffs(p, t) = let v=ann([t], p)\n                    [v[1], ω₁ + v[2], ω₂ + v[3]]\n               end \n\nH = Hamiltonian(H0, [H1, H2, H3], coeffs)","category":"page"},{"location":"examples/SQRTiSWAP.html","page":"√iSWAP","title":"√iSWAP","text":"states = [fockstate(bs, 0)⊗fockstate(bs, 0),\n          fockstate(bs, 0)⊗fockstate(bs, 1),\n          fockstate(bs, 1)⊗fockstate(bs, 0),\n          fockstate(bs, 1)⊗fockstate(bs, 1)]\n\ntrans = UnitaryTransform(states, [[1 0 0 0];\n                                  [0 1 1.0im 0]/√2;\n                                  [0 1.0im 1 0]/√2;\n                                  [0 0.0 0.0 1.0]])","category":"page"},{"location":"examples/SQRTiSWAP.html","page":"√iSWAP","title":"√iSWAP","text":"bcs(p) = 2.0*sum(ann([t0], p).^2 + ann([t1], p).^2)\n                 \ncost = CostFunction((x,y)-> 1.0-real(x'*y), bcs)","category":"page"},{"location":"examples/SQRTiSWAP.html","page":"√iSWAP","title":"√iSWAP","text":"prob = QOCProblem(H, trans,(t0, t1), cost)","category":"page"},{"location":"examples/SQRTiSWAP.html","page":"√iSWAP","title":"√iSWAP","text":"here we use the gaussian pulses as initial guess and solve the QOCProblem","category":"page"},{"location":"examples/SQRTiSWAP.html","page":"√iSWAP","title":"√iSWAP","text":"sol = solve(prob, θ, Adam(0.01); maxiter=100)","category":"page"},{"location":"examples/SQRTiSWAP.html","page":"√iSWAP","title":"√iSWAP","text":"\u001b[32mProgress: 100%|█████████████████████████████████████████| Time: 0:54:37\u001b[39m\r\n\u001b[34m  distance:     0.008841084452384546\u001b[39m\r\n\u001b[34m  constraints:  0.0003239125678191379\u001b[39m","category":"page"},{"location":"examples/SQRTiSWAP.html","page":"√iSWAP","title":"√iSWAP","text":"plot(sol.distance_trace, label=\"distance\")\nplot!(sol.constraints_trace, label=\"constraints\")","category":"page"},{"location":"examples/SQRTiSWAP.html","page":"√iSWAP","title":"√iSWAP","text":"(Image: svg)","category":"page"},{"location":"examples/SQRTiSWAP.html","page":"√iSWAP","title":"√iSWAP","text":"optimal pulses to tune the flux lines and capacitive coupling","category":"page"},{"location":"examples/SQRTiSWAP.html","page":"√iSWAP","title":"√iSWAP","text":"g(t) = ann([t], sol.params)[1]/2π\nf1(t) = ann([t], sol.params)[2]/2π\nf2(t) = ann([t], sol.params)[3]/2π","category":"page"},{"location":"examples/SQRTiSWAP.html","page":"√iSWAP","title":"√iSWAP","text":"ts = t0:t1/100:t1\nplot(ts, g.(ts), label=\"g/2π\")\nplot!(ts, f1.(ts), label=\"f₁/2π\")\nplot!(ts, f2.(ts), label=\"f₂/2π\")\nxlabel!(\"Time (ns)\")\nylabel!(\"Waveforms (GHz)\")","category":"page"},{"location":"examples/SQRTiSWAP.html","page":"√iSWAP","title":"√iSWAP","text":"(Image: svg)","category":"page"},{"location":"introduction.html#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"introduction.html","page":"Introduction","title":"Introduction","text":"Optimal control strategies pervade a wide range of fields in science and engineering. In particular, quantum optimal control (QOC) has the potential to extract the best of the quantum technologies. QOC techniques are routinely employed to coherently manipulate and drive the quantum system to a given state or to perform a given quantum operation (or gate). In practice, the system dynamics and/or objective function to be minimized in QOC problems can be quite involved and often they do not yield to a simple analytical treatment (except in a few cases such as DRAG, STIRAP etc.). Therefore, one must often resort to computational methods.","category":"page"},{"location":"introduction.html","page":"Introduction","title":"Introduction","text":"Numerical techniques to solve QOC problems fall into two categories: gradient based and gradient free methods. As a general rule of thumb, gradient free methods such as CRAB and dCRAB are suitable for problems involving few tens of parameters. However, they require large number of iterations to converge as the parameter size increases and gradient based techniques should be preferred, whenever it is possible to evaluate the gradients efficiently. Among the gradient based methods, GRAPE and Krotov solve QOC problems by representing the drive signals as piece-wise constant functions and iteratively optimize these discrete values based on the gradient of the cost function with respect to the control parameters. In these approaches, for a given set of control signals, the resulting unitary transformation is computed by first-order Trotterization of each time slice. These methods are inherently prone to discretization errors and one must sample the control signals sufficiently to obtain high fidelity protocols. A continuous parametrization of drive signals, combined with higher-order ordinary differential equation solvers are indispensible for solving optimal control problems when accuracy can not be traded with computational effort (see Gradient Optimization of Analytical conTrols (GOAT) for a thorough discussion).","category":"page"},{"location":"introduction.html","page":"Introduction","title":"Introduction","text":"In this library, we implement a gradient based approach to solve a generic QOC problem. We rely on automatic differentiation (AD) to automatically write the adjoint equations, necessary to calculate the gradients for any user defined parametrized control knobs and objective function. These equations coupled with the dynamical equations of the system are then efficiently solved to evaluate gradients. The control parameters can then be updated iteratively using any gradient based method to optimize the objective function.","category":"page"},{"location":"introduction.html#Why-do-we-need-a-dedicated-library-for-quantum-optimal-control?","page":"Introduction","title":"Why do we need a dedicated library for quantum optimal control?","text":"","category":"section"},{"location":"introduction.html","page":"Introduction","title":"Introduction","text":"SciML ecosystem already supports solving optimal control problems via sensitivity analysis. In principle, quantum optimal control problems can be solved with this approach, however, it has two shortcomings:","category":"page"},{"location":"introduction.html","page":"Introduction","title":"Introduction","text":"a) Time evolution of Schrodinger or Master equation must be expressed only in terms of real numbers i.e. by separating the real and imaginary parts of operators and kets (it also means that we can not easily interface with QuantumOptics.jl). Otherwise, we'll run into errors while calculating gradients of cost function (loss) using AD.","category":"page"},{"location":"introduction.html","page":"Introduction","title":"Introduction","text":"b) The size of Hilbert space and/or the number of parameters in QOC problems can be large. In such cases, it is beneficial to implement the RHS of time evolution equations with Intel MKL or CUBLAS libraries. However, AD once again fails if the equations contain calls to functions not written in pure Julia (for e.g. when mul! points to Intel MKL library).","category":"page"},{"location":"introduction.html","page":"Introduction","title":"Introduction","text":"In Sisyphus.jl package we solve these problems by separating the AD part from the time evolution. The result is a high-performance library for quantum optimal control that enables users to: describe a general quantum optimal control problem in the familiar language of QuantumOptics.jl with almost any objective for optimization, select any ODE solver, optimizer (in Flux.jl and NLopt.jl) and solve it fast!","category":"page"},{"location":"index.html#Sisyphus","page":"Home","title":"Sisyphus","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Sisyphus.jl is a flexible high-performance Julia package for gradient based quantum optimal control. It is well integrated into the Julia ecosystem by supporting definitions of quantum objects from the QuantumOptics.jl library, automatic differentiation through Flux.jl, it relies on OrdinaryDiffEq.jl to simulate the dynamics of quantum systems and can be used in conjunction with any optimizer in the Flux or NLopt[1] packages. The solver is implemented with the CommonSolve API. The simulation backend is multi-threaded (uses MKLSparse library) and autoscales on multicore CPUs depending on the problem size. It can also be seamlessly run on a GPU and it is suitable for solving large scale quantum optimal control problems.","category":"page"},{"location":"index.html#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"optimization of a two level state transfer problem (Image: )","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"optimization of GHZ state preparation in a linear chain of 12 atoms on a GPU (Image: )","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"[1]: including derivative free optimization algorithms","category":"page"},{"location":"tutorial.html#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"The main goal of this tutorial is to introduce the terminology and workflow of the package.","category":"page"},{"location":"tutorial.html#Constructing-a-[Hamiltonian](@ref)","page":"Tutorial","title":"Constructing a Hamiltonian","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"We split the Hamiltonian into time-independent and time-dependent parts. Operators constituting the Hamiltonian are represented by QuantumOptics operators. For a list of operators we submit a drives function that returns the corresponding list of real-valued drives that multiplies the operators respectively. Below is a construction of a simple two-level Hamiltonian with a parameterized Gaussian shaped drive","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"H(t)hbaromega_0 = -frac12sigma_z + Omega(p t)sigma_x","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"bs = SpinBasis(1//2)\nΩ(p, t) = [p[1] * exp(-p[2] * t^2) + p[3]]\nH = Hamiltonian(-0.5*sigmaz(bs), [sigmax(bs)], Ω)","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"The real valued drives can be any function in Julia, as long as it is differentiable. You can find some examples showcasing the use of neural networks, piecewise constant and linear functions in the notebooks.","category":"page"},{"location":"tutorial.html#Defining-a-[Transform](@ref)","page":"Tutorial","title":"Defining a Transform","text":"","category":"section"},{"location":"tutorial.html#a)-[StateTransform](@ref)","page":"Tutorial","title":"a) StateTransform","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Transformation can be defined between two Kets as in the following code.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"bs = SpinBasis(1//2)\ntrans = StateTransform(spindown(bs) => spinup(bs))","category":"page"},{"location":"tutorial.html#b)-[UnitaryTransform](@ref)","page":"Tutorial","title":"b) UnitaryTransform","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"It can alternatively be defined on a vector of Kets by providing unitary matrix that acts on the subspace spanned by them and represents the desired unitary evolution.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"bs = FockBasis(5)\n\nstates = [fockstate(bs, 0)⊗fockstate(bs, 0),\n          fockstate(bs, 0)⊗fockstate(bs, 1),\n          fockstate(bs, 1)⊗fockstate(bs, 0),\n          fockstate(bs, 1)⊗fockstate(bs, 1)]\n\ntrans = UnitaryTransform(states, [[1.0 0.0 0.0 0.0];\n                                  [0.0 1.0 1.0im 0.0]/√2;\n                                  [0.0 1.0im 1.0 0.0]/√2;\n                                  [0.0 0.0 0.0 1.0]])","category":"page"},{"location":"tutorial.html#Constructing-a-[CostFunction](@ref)","page":"Tutorial","title":"Constructing a CostFunction","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Cost function is composed of a distance function measuring the overlap of the quantum states and the optional constraints on the shape of pulses. The following code defines a cost function that measures the infidelity between quantum states and constrains the pulse to zero at initial and final times t0 and t1.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"(t0, t1) = (0.0, 1.0)\nΩ(p, t) = [p[1] * exp(-p[2] * t^2) + p[3]]\ncost = CostFunction((x, y) -> 1.0 - abs2(x' * y),\n                     p -> Ω(p, t0)[1]^2 + Ω(p, t1)[1]^2)","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"The solver automatically calculates the gradient of the distance and constraints function wrt the parameters of the problem. Therefore, the CostFunction arguments have to be differentiable real valued functions (Zygote handles most functions, just try!).","category":"page"},{"location":"tutorial.html#Creating-and-solving-a-[QOCProblem](@ref)","page":"Tutorial","title":"Creating and solving a QOCProblem","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Once we have constructed the Hamiltonian, cost function, and target unitary transformation, we can define a quantum optimal control problem by submitting a timeframe (t0, t1) for the evolution along the previously mentioned objects and functions. QOCProblem can be solved by invoking the solve method that can further be customized, e.g. through the selection of an optimizer or by setting optimization hyperparameters like below.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"prob = QOCProblem(H, trans, (t0, t1), cost)\nsol = solve(prob, initial_params, ADAM(0.01);)","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"The Solution returned by the solver contains the optimal parameters and also the values of distance metric and constraints during the optimization process.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Optionally, you can use the following keywords while invoking the solve method:","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"a) maxiter allows to set the maximum number of iterations, the default value is 100.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"b) save_iters to save the parameters tried by the optimizer at the specified iterations (useful for visualization of optimization). By default, the Solution object returned by the solver does not contain intermediate results.","category":"page"},{"location":"tutorial.html#Selecting-an-optimizer","page":"Tutorial","title":"Selecting an optimizer","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"User can pick any of the available optimizers from the Flux or NLopt packages, for example","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"using Flux.Optimise: RMSProp\nsol = solve(prob, initial_params, RMSProp(0.01); maxiter=100)","category":"page"},{"location":"tutorial.html#Selecting-a-differential-equation-solver","page":"Tutorial","title":"Selecting a differential equation solver","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"The ODE solver used to compute the system dynamics and gradients can be chosen with the keyword alg.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"sol = solve(prob, initial_params, ADAM(0.01); maxiter=100, alg=DP5(), abstol=1e-6, reltol=1e-6)","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"You may select appropriate ODE solvers available in OrdinaryDiffEq package. By default Sisyphus.jl uses Tsit5() algorithm, we encourage you to go through the documentation of ODE Solvers and try different algorithms to identify the algorithm best suited for your problem. In addition, you can also control the solver tolerances by setting abstol and reltol.","category":"page"},{"location":"tutorial.html#Optimization-in-the-presence-of-noise","page":"Tutorial","title":"Optimization in the presence of noise","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Optimal control problems in the presence of Lindbladian noise can be solved by converting them into an equivalent closed system problem by vectorizing the master equation. Here, we only provide tools to convert Hamiltonian and Transforms into their vectorized forms. However, it is the responsibility of the users to provide an appropriate distance measure between the two density matrices in the CostFunction (check examples) while working with the vectorized forms. For example, one can write Frobenius norm in its vectorized form as","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"rho - sigma_F = sqrttextTr(rho - sigma)^dagger(rho - sigma) = sqrttextvec(rho - sigma)^daggertextvec(rho - sigma)","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"and define a correspoding distance function as (x, y) -> 1.0 - sqrt((x - y)' * (x - y)).","category":"page"},{"location":"tutorial.html#Solving-problems-on-GPU","page":"Tutorial","title":"Solving problems on GPU","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Usually, all the kets and operators in QOCProblem are allocated on the CPU. In order to solve the problem on a GPU, we need to move the data to GPU memory, this can be done simply with the cu function as shown below. Once the data is moved to the GPU, the problem can be solved with the solve method as usual","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"cu_prob = cu(QOCProblem(H, trans, (t0, t1), cost))\nsolve(cu_prob, init_params, ADAM(0.1); maxiter=100)","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"GPUs have better single precision performance, if your problem does not require double precision, it is better to use single precision to obtain results quicker (it also reduces the memory footprint). We provide convert method to automatically convert all data types to single precision,","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"prob = cu(convert(Float32, QOCProblem(H, trans, (t0, t1), cost)))","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"notebooks demonstrating these features can be found in the examples.","category":"page"},{"location":"tutorial.html#How-to-choose-a-CostFunction?","page":"Tutorial","title":"How to choose a CostFunction?","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"We have to bear in mind that the distance function (specified in CostFunction) must operate on arrays allocated on GPU. Most of the time, Julia's GPU compiler automatically generates CUDA kernels behind the scenes, both for distance and it's gradient! However it fails sometimes, for example, you should use,","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"cost = CostFunction((x, y) -> 1.0 - real(sum(conj(x) .* y))","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"instead of,","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"cost = CostFunction((x, y) -> 1.0 - real(x' * y)","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"eventhough they are equivalent. Solving this in general is beyond the scope of Sisyphus.jl.","category":"page"},{"location":"examples/CCZ.html#CCZ-gate-in-Rydberg-atoms","page":"CCZ gate in Rydberg atoms","title":"CCZ gate in Rydberg atoms","text":"","category":"section"},{"location":"examples/CCZ.html","page":"CCZ gate in Rydberg atoms","title":"CCZ gate in Rydberg atoms","text":"H = fracOmega(t)2sum_j = 1^N lefte^iphi(t)  sigma_+^j  +  e^-iphi(t) sigma_-^j - Delta(t) n_j right + sum_i  j fracVi-j^6n_in_j ","category":"page"},{"location":"examples/CCZ.html","page":"CCZ gate in Rydberg atoms","title":"CCZ gate in Rydberg atoms","text":"see Levine et al.","category":"page"},{"location":"examples/CCZ.html","page":"CCZ gate in Rydberg atoms","title":"CCZ gate in Rydberg atoms","text":"using Sisyphus\nusing QuantumOptics\nusing Flux, DiffEqFlux\nusing Plots\nusing Random\nusing LinearAlgebra\nusing ProgressMeter\n\n\nProgressMeter.ijulia_behavior(:clear)","category":"page"},{"location":"examples/CCZ.html","page":"CCZ gate in Rydberg atoms","title":"CCZ gate in Rydberg atoms","text":"V = 2π*15.0; # MHz","category":"page"},{"location":"examples/CCZ.html","page":"CCZ gate in Rydberg atoms","title":"CCZ gate in Rydberg atoms","text":"n_atoms = 3\n\nbs = NLevelBasis(3)\nbsys = tensor([bs for i in 1:n_atoms]...)\n\nspi = transition(bs, 3, 2)\nsmi = transition(bs, 2, 3)\nni = transition(bs, 3, 3)","category":"page"},{"location":"examples/CCZ.html","page":"CCZ gate in Rydberg atoms","title":"CCZ gate in Rydberg atoms","text":"Operator(dim=3x3)\n  basis: NLevel(N=3)sparse([3], [3], ComplexF64[1.0 + 0.0im], 3, 3)","category":"page"},{"location":"examples/CCZ.html","page":"CCZ gate in Rydberg atoms","title":"CCZ gate in Rydberg atoms","text":"H0 =  V*sum([embed(bsys, [i, j], [ni, ni])/abs(i-j)^6  for i in 1:n_atoms for j in i+1:n_atoms])\nH1 = sum([embed(bsys, [i], [ni]) for i in [1, n_atoms]])\nH2 = sum([embed(bsys, [i], [spi]) for i in [1, n_atoms]]) \nH2 += sum([embed(bsys, [i], [smi]) for i in [1, n_atoms]]) \nH3 = 1.0im*(sum([embed(bsys, [i], [spi]) for i in [1, n_atoms]]))\nH3 -= 1.0im*(sum([embed(bsys, [i], [smi]) for i in [1, n_atoms]]))","category":"page"},{"location":"examples/CCZ.html","page":"CCZ gate in Rydberg atoms","title":"CCZ gate in Rydberg atoms","text":"states = [\n    tensor([nlevelstate(bs, i+1) for i in digits(j-1; base = 2, pad = n_atoms)]...)\n        for j in 1:2^n_atoms]","category":"page"},{"location":"examples/CCZ.html","page":"CCZ gate in Rydberg atoms","title":"CCZ gate in Rydberg atoms","text":"U = Matrix{ComplexF64}(Diagonal(ones(2^n_atoms)))\nU[2^n_atoms, 2^n_atoms] = -1.0+0.0im","category":"page"},{"location":"examples/CCZ.html","page":"CCZ gate in Rydberg atoms","title":"CCZ gate in Rydberg atoms","text":"trans = UnitaryTransform(states, U)","category":"page"},{"location":"examples/CCZ.html","page":"CCZ gate in Rydberg atoms","title":"CCZ gate in Rydberg atoms","text":"n_neurons = 8\nann = FastChain(FastDense(1, n_neurons, tanh), \n                FastDense(n_neurons, n_neurons, tanh), \n                FastDense(n_neurons, n_neurons, tanh), \n                FastDense(n_neurons, 3))\nθ = initial_params(ann)     \nn_params = length(θ);\nRandom.seed!(3)\nθ = 2.0*rand(n_params).-1.0","category":"page"},{"location":"examples/CCZ.html","page":"CCZ gate in Rydberg atoms","title":"CCZ gate in Rydberg atoms","text":"t0, t1 = 0.0, 1.0\nsigmoid(x)= @. 2π*7 / (1 + exp(-x))\ncoeffs(p, t) = let vals = ann([t], p)\n                [-vals[1], sigmoid(vals[2])*cos(vals[3]), sigmoid(vals[2])*sin(vals[3])]\n               end    \ncost = CostFunction((x, y) -> 1.0-real(x'*y),\n                     p->2e-2*(sigmoid(ann([t0], p)[2])^2 + sigmoid(ann([t1], p)[2])^2))\n\nH = Hamiltonian(H0, [H1, H2, H3], coeffs)\nprob = QOCProblem(H, trans, (t0, t1), cost)","category":"page"},{"location":"examples/CCZ.html","page":"CCZ gate in Rydberg atoms","title":"CCZ gate in Rydberg atoms","text":"sol = solve(prob, θ, Adam(0.1); maxiter=2000, abstol=1e-4, reltol=1e-4)","category":"page"},{"location":"examples/CCZ.html","page":"CCZ gate in Rydberg atoms","title":"CCZ gate in Rydberg atoms","text":"\u001b[32mProgress:  71%|█████████████████████████████            |  ETA: 0:03:30\u001b[39m\r\n\u001b[34m  distance:     0.25000116952059076\u001b[39m\r\n\u001b[34m  constraints:  1.1512625700095713e-5\u001b[39m","category":"page"},{"location":"examples/CCZ.html","page":"CCZ gate in Rydberg atoms","title":"CCZ gate in Rydberg atoms","text":"cost.constraints = p->(sigmoid(ann([t0], p)[2])^2 + sigmoid(ann([t1], p)[2])^2)\nsol1 = solve(prob, sol.params, Adam(0.008); maxiter=500, abstol=1e-6, reltol=1e-6)","category":"page"},{"location":"examples/CCZ.html","page":"CCZ gate in Rydberg atoms","title":"CCZ gate in Rydberg atoms","text":"\u001b[32mProgress: 100%|█████████████████████████████████████████| Time: 0:03:40\u001b[39m\r\n\u001b[34m  distance:     0.006063003962643532\u001b[39m\r\n\u001b[34m  constraints:  0.012359362552093491\u001b[39m","category":"page"},{"location":"examples/CCZ.html","page":"CCZ gate in Rydberg atoms","title":"CCZ gate in Rydberg atoms","text":"Ω(t) = sigmoid(ann([t], sol1.params)[2])/2π\nΔ(t) = -ann([t], sol1.params)[1]/2π\nϕ(t) = ann([t], sol1.params)[3]","category":"page"},{"location":"examples/CCZ.html","page":"CCZ gate in Rydberg atoms","title":"CCZ gate in Rydberg atoms","text":"ts = collect(t0:t1/100:t1)\nplot(ts, Ω.(ts), label=\"Ω/2π (MHz)\")\nplot!(ts, Δ.(ts), label=\"Δ/2π (MHz)\")\nplot!(ts, ϕ.(ts), label=\"ϕ (Radians)\")\nylabel!(\"Waveform\")\nxlabel!(\"Time (µs)\")","category":"page"},{"location":"examples/CCZ.html","page":"CCZ gate in Rydberg atoms","title":"CCZ gate in Rydberg atoms","text":"(Image: svg)","category":"page"},{"location":"examples/CCZ.html","page":"CCZ gate in Rydberg atoms","title":"CCZ gate in Rydberg atoms","text":"tout, psit22 = schroedinger_dynamic(ts, nlevelstate(bs, 2)⊗nlevelstate(bs, 2),\n                                    H, sol1.params)\ntout, psit21 = schroedinger_dynamic(ts, nlevelstate(bs, 2)⊗nlevelstate(bs, 1),\n                                    H, sol1.params)\ntout, psit12 = schroedinger_dynamic(ts, nlevelstate(bs, 1)⊗nlevelstate(bs, 2),\n                                    H, sol1.params)\ntout, psit11 = schroedinger_dynamic(ts, nlevelstate(bs, 1)⊗nlevelstate(bs, 1),\n                                    H, sol1.params)","category":"page"},{"location":"examples/CCZ.html","page":"CCZ gate in Rydberg atoms","title":"CCZ gate in Rydberg atoms","text":"plot(tout, [real((nlevelstate(bs, 2)⊗nlevelstate(bs, 2))'*elm) for elm in psit22], label=\"|22⟩\")\nplot!(tout, [real((nlevelstate(bs, 2)⊗nlevelstate(bs, 1))'*elm) for elm in psit21], label=\"|21⟩\")\nplot!(tout, [real((nlevelstate(bs, 1)⊗nlevelstate(bs, 2))'*elm) for elm in psit12], label=\"|12⟩\")\nplot!(tout, [real((nlevelstate(bs, 1)⊗nlevelstate(bs, 1))'*elm) for elm in psit11], label=\"|11⟩\", legend=:bottomright)        \nxlabel!(\"Time (µs)\")\nylabel!(\"Overlap (⟨ij|ψ⟩)\")","category":"page"},{"location":"examples/CCZ.html","page":"CCZ gate in Rydberg atoms","title":"CCZ gate in Rydberg atoms","text":"(Image: svg)","category":"page"}]
}
